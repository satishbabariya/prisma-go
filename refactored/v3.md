# Prisma-Go Complete Restructuring Documentation

> **Version:** 2.0.0  
> **Date:** December 2025  
> **Status:** Architecture Design & Implementation Guide

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Current State Analysis](#current-state-analysis)
3. [Proposed Architecture](#proposed-architecture)
4. [Complete Directory Structure](#complete-directory-structure)
5. [Core Interfaces & Contracts](#core-interfaces--contracts)
6. [Implementation Examples](#implementation-examples)
7. [Migration Strategy](#migration-strategy)
8. [Testing Strategy](#testing-strategy)
9. [Build & Development](#build--development)
10. [Documentation Requirements](#documentation-requirements)
11. [Timeline & Milestones](#timeline--milestones)

---

## Executive Summary

### Current Issues

The existing prisma-go codebase has several architectural issues:
- **Tight coupling** between layers (PSL → Migration → Query → Generator)
- **No clear boundaries** between public and internal APIs
- **Limited extensibility** - hard to add custom generators or database providers
- **Testing challenges** - difficult to mock and test components independently
- **Mixed concerns** - business logic mixed with data access and presentation

### Proposed Solution

Implement a **Clean Architecture** approach with:
- Clear layered structure (Domain → Use Cases → Interface Adapters → Frameworks)
- Repository pattern for data access
- Service layer for business logic
- Interface-based design for flexibility
- Comprehensive plugin system
- Full dependency injection

### Expected Outcomes

- **80% improvement** in testability through dependency injection
- **50% reduction** in coupling between components
- **Zero breaking changes** for existing users (backward compatible)
- **Plugin ecosystem** enabling third-party extensions
- **Production-ready** with proper logging, monitoring, and error handling

---

## Current State Analysis

### Existing Structure

```
prisma-go/
├── cli/                  # CLI commands (mixed concerns)
├── generator/            # Code generation (tightly coupled)
├── migrate/              # Migration engine (direct DB access)
├── psl/                  # Schema parsing (core logic mixed with utils)
├── query/                # Query compiler (no abstraction)
├── runtime/              # Runtime client (limited features)
├── telemetry/            # Telemetry (standalone)
└── tests/e2e/            # E2E tests only
```

### Problems Identified

**1. Architectural Issues:**
```go
// PROBLEM: Direct coupling
package migrate

import "github.com/satishbabariya/prisma-go/psl"
import "github.com/satishbabariya/prisma-go/query"

// Migration engine directly depends on all other packages
type Engine struct {
    schema *psl.Schema
    query  *query.Compiler
}
```

**2. No Dependency Injection:**
```go
// PROBLEM: Hard-coded dependencies
func NewMigrationEngine() *Engine {
    return &Engine{
        db: sql.Open("postgres", "hardcoded-connection"), // Can't mock
    }
}
```

**3. Mixed Concerns:**
```go
// PROBLEM: Business logic + data access + presentation
func (e *Engine) CreateMigration(name string) error {
    schema := e.parseSchema()        // Parsing
    diff := e.compareToDB()          // Business logic
    sql := e.generateSQL()           // SQL generation
    e.db.Exec(sql)                   // Data access
    fmt.Println("Migration created") // Presentation
    return nil
}
```

**4. Limited Testing:**
```
tests/e2e/  # Only end-to-end tests
# Missing: Unit tests, integration tests, benchmarks
```

---

## Proposed Architecture

### Clean Architecture Layers

```
┌─────────────────────────────────────────────────────────┐
│                    FRAMEWORKS & DRIVERS                  │
│  (CLI, Web API, Database Drivers, File System)          │
│                                                           │
│  cmd/prisma/    adapters/database/    adapters/storage/  │
└─────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────┐
│              INTERFACE ADAPTERS (Ports)                   │
│  (Controllers, Presenters, Gateways, Repositories)       │
│                                                           │
│  repository/    service/    config/                       │
└─────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────┐
│              APPLICATION BUSINESS RULES                   │
│  (Use Cases, Application Services)                        │
│                                                           │
│  service/migration_service.go                             │
│  service/generate_service.go                              │
└─────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────┐
│           ENTERPRISE BUSINESS RULES (Domain)              │
│  (Entities, Value Objects, Domain Services)               │
│                                                           │
│  core/schema/    core/migration/    core/query/           │
└─────────────────────────────────────────────────────────┘
```

### Dependency Rule

**Dependencies point inward only:**
- Frameworks → Interface Adapters → Application → Domain
- Domain layer has ZERO dependencies on outer layers
- Interface Adapters depend on Use Cases, not implementations
- Use Cases depend on Domain entities and interfaces

---

## Complete Directory Structure

```
prisma-go/
│
├── cmd/                                    # Entrypoints (Framework Layer)
│   ├── prisma/                            # Main CLI
│   │   ├── main.go                        # CLI entry point
│   │   ├── container.go                   # Dependency injection container
│   │   └── commands/                      # CLI commands
│   │       ├── init.go
│   │       ├── generate.go
│   │       ├── migrate.go
│   │       ├── db.go
│   │       ├── format.go
│   │       └── validate.go
│   │
│   └── prisma-generate/                   # Standalone generator (optional)
│       └── main.go
│
├── pkg/                                   # Public API (External Interface)
│   ├── client/                           # Client package (main user-facing API)
│   │   ├── client.go                     # Client interface
│   │   ├── options.go                    # Client options
│   │   ├── transaction.go                # Transaction handling
│   │   ├── middleware.go                 # Middleware interface
│   │   ├── batch.go                      # Batch operations
│   │   ├── raw.go                        # Raw SQL execution
│   │   └── hooks.go                      # Lifecycle hooks
│   │
│   ├── schema/                           # Schema package
│   │   ├── parser.go                     # Public schema parser
│   │   ├── validator.go                  # Public schema validator
│   │   ├── formatter.go                  # Schema formatter
│   │   ├── types.go                      # Schema types (AST)
│   │   └── errors.go                     # Schema errors
│   │
│   └── generator/                        # Generator package
│       ├── generator.go                  # Generator interface
│       ├── plugin.go                     # Plugin system
│       ├── template.go                   # Template helpers
│       ├── config.go                     # Generator config
│       └── errors.go                     # Generator errors
│
├── internal/                             # Internal implementation (private)
│   │
│   ├── core/                            # Domain Layer (Business Rules)
│   │   │
│   │   ├── schema/                      # Schema Domain (PSL - Layer 1)
│   │   │   ├── domain/                  # Domain models
│   │   │   │   ├── schema.go           # Schema aggregate
│   │   │   │   ├── model.go            # Model entity
│   │   │   │   ├── field.go            # Field value object
│   │   │   │   ├── relation.go         # Relation value object
│   │   │   │   ├── enum.go             # Enum entity
│   │   │   │   ├── index.go            # Index value object
│   │   │   │   └── datasource.go       # Datasource entity
│   │   │   │
│   │   │   ├── ast/                    # Abstract Syntax Tree
│   │   │   │   ├── ast.go              # AST node definitions
│   │   │   │   ├── visitor.go          # AST visitor pattern
│   │   │   │   └── walker.go           # AST walker
│   │   │   │
│   │   │   ├── lexer/                  # Lexical analysis
│   │   │   │   ├── lexer.go            # Lexer implementation
│   │   │   │   ├── token.go            # Token definitions
│   │   │   │   └── scanner.go          # Character scanner
│   │   │   │
│   │   │   ├── parser/                 # Syntax analysis
│   │   │   │   ├── parser.go           # Parser implementation
│   │   │   │   ├── expression.go       # Expression parsing
│   │   │   │   ├── statement.go        # Statement parsing
│   │   │   │   └── errors.go           # Parser errors
│   │   │   │
│   │   │   ├── validator/              # Schema validation
│   │   │   │   ├── validator.go        # Main validator
│   │   │   │   ├── rules/              # Validation rules
│   │   │   │   │   ├── model_rules.go
│   │   │   │   │   ├── field_rules.go
│   │   │   │   │   ├── relation_rules.go
│   │   │   │   │   └── attribute_rules.go
│   │   │   │   └── errors.go           # Validation errors
│   │   │   │
│   │   │   ├── formatter/              # Code formatting
│   │   │   │   ├── formatter.go        # Formatter implementation
│   │   │   │   ├── printer.go          # AST printer
│   │   │   │   └── options.go          # Formatting options
│   │   │   │
│   │   │   └── diagnostics/            # Error diagnostics
│   │   │       ├── diagnostic.go       # Diagnostic types
│   │   │       ├── reporter.go         # Error reporter
│   │   │       └── printer.go          # Pretty printer
│   │   │
│   │   ├── migration/                   # Migration Domain (Layer 2)
│   │   │   ├── domain/                  # Domain models
│   │   │   │   ├── migration.go        # Migration aggregate
│   │   │   │   ├── change.go           # Change entity
│   │   │   │   ├── history.go          # History entity
│   │   │   │   ├── plan.go             # Migration plan
│   │   │   │   └── state.go            # Database state
│   │   │   │
│   │   │   ├── introspector/            # Database introspection
│   │   │   │   ├── interface.go        # Introspector interface
│   │   │   │   ├── postgres.go         # Postgres introspector
│   │   │   │   ├── mysql.go            # MySQL introspector
│   │   │   │   ├── sqlite.go           # SQLite introspector
│   │   │   │   └── metadata.go         # Database metadata types
│   │   │   │
│   │   │   ├── differ/                  # Schema comparison
│   │   │   │   ├── differ.go           # Main differ
│   │   │   │   ├── table_differ.go     # Table comparison
│   │   │   │   ├── column_differ.go    # Column comparison
│   │   │   │   ├── index_differ.go     # Index comparison
│   │   │   │   ├── constraint_differ.go # Constraint comparison
│   │   │   │   └── changes.go          # Change types
│   │   │   │
│   │   │   ├── planner/                 # Migration planning
│   │   │   │   ├── planner.go          # Plan generator
│   │   │   │   ├── optimizer.go        # Plan optimizer
│   │   │   │   ├── sorter.go           # Dependency sorter
│   │   │   │   └── validator.go        # Plan validator
│   │   │   │
│   │   │   └── executor/                # Migration execution
│   │   │       ├── executor.go         # Main executor
│   │   │       ├── rollback.go         # Rollback handler
│   │   │       ├── transaction.go      # Transaction handler
│   │   │       └── hooks.go            # Execution hooks
│   │   │
│   │   ├── query/                       # Query Domain (Layer 3)
│   │   │   ├── domain/                  # Domain models
│   │   │   │   ├── query.go            # Query aggregate
│   │   │   │   ├── selection.go        # Selection entity
│   │   │   │   ├── filter.go           # Filter value object
│   │   │   │   ├── relation.go         # Relation inclusion
│   │   │   │   └── aggregation.go      # Aggregation types
│   │   │   │
│   │   │   ├── ast/                     # Query AST
│   │   │   │   ├── ast.go              # AST node definitions
│   │   │   │   ├── select.go           # Select AST
│   │   │   │   ├── insert.go           # Insert AST
│   │   │   │   ├── update.go           # Update AST
│   │   │   │   ├── delete.go           # Delete AST
│   │   │   │   └── expression.go       # Expression AST
│   │   │   │
│   │   │   ├── builder/                 # Query building
│   │   │   │   ├── interface.go        # Builder interface
│   │   │   │   ├── select_builder.go   # Select builder
│   │   │   │   ├── insert_builder.go   # Insert builder
│   │   │   │   ├── update_builder.go   # Update builder
│   │   │   │   ├── delete_builder.go   # Delete builder
│   │   │   │   ├── where_builder.go    # Where clause builder
│   │   │   │   └── relation_resolver.go # Relation resolution
│   │   │   │
│   │   │   ├── compiler/                # Query compilation
│   │   │   │   ├── compiler.go         # Main compiler
│   │   │   │   ├── optimizer.go        # Query optimizer
│   │   │   │   ├── validator.go        # Query validator
│   │   │   │   └── analyzer.go         # Query analyzer
│   │   │   │
│   │   │   ├── executor/                # Query execution
│   │   │   │   ├── interface.go        # Executor interface
│   │   │   │   ├── executor.go         # Main executor
│   │   │   │   ├── mapper.go           # Result mapper
│   │   │   │   ├── cache.go            # Query cache
│   │   │   │   └── batch.go            # Batch executor
│   │   │   │
│   │   │   └── sqlgen/                  # SQL generation
│   │   │       ├── interface.go        # Generator interface
│   │   │       ├── postgres.go         # Postgres SQL generator
│   │   │       ├── mysql.go            # MySQL SQL generator
│   │   │       ├── sqlite.go           # SQLite SQL generator
│   │   │       ├── common.go           # Common SQL utilities
│   │   │       └── dialect.go          # SQL dialect abstraction
│   │   │
│   │   └── generator/                   # Generator Domain (Layer 4)
│   │       ├── domain/                  # Domain models
│   │       │   ├── model.go            # Generated model
│   │       │   ├── field.go            # Generated field
│   │       │   ├── method.go           # Generated method
│   │       │   └── file.go             # Generated file
│   │       │
│   │       ├── analyzer/                # Schema analysis
│   │       │   ├── analyzer.go         # Main analyzer
│   │       │   ├── model_analyzer.go   # Model analysis
│   │       │   ├── relation_analyzer.go # Relation analysis
│   │       │   ├── field_analyzer.go   # Field analysis
│   │       │   └── type_mapper.go      # Type mapping (Prisma → Go)
│   │       │
│   │       ├── template/                # Template system
│   │       │   ├── engine.go           # Template engine
│   │       │   ├── helpers.go          # Template helpers
│   │       │   ├── functions.go        # Template functions
│   │       │   └── templates/          # Template files
│   │       │       ├── client.tmpl     # Client template
│   │       │       ├── model.tmpl      # Model template
│   │       │       ├── query.tmpl      # Query builder template
│   │       │       ├── enum.tmpl       # Enum template
│   │       │       └── types.tmpl      # Types template
│   │       │
│   │       └── writer/                  # Code writing
│   │           ├── writer.go           # Main writer
│   │           ├── formatter.go        # Code formatter
│   │           └── organizer.go        # Import organizer
│   │
│   ├── adapters/                        # Interface Adapters Layer
│   │   │
│   │   ├── database/                    # Database adapters (Infrastructure)
│   │   │   ├── interface.go            # Database adapter interface
│   │   │   │
│   │   │   ├── postgres/               # PostgreSQL adapter
│   │   │   │   ├── adapter.go          # Adapter implementation
│   │   │   │   ├── connection.go       # Connection management
│   │   │   │   ├── transaction.go      # Transaction handling
│   │   │   │   ├── types.go            # Type mapping
│   │   │   │   └── introspector.go     # Introspection queries
│   │   │   │
│   │   │   ├── mysql/                  # MySQL adapter
│   │   │   │   ├── adapter.go
│   │   │   │   ├── connection.go
│   │   │   │   ├── transaction.go
│   │   │   │   ├── types.go
│   │   │   │   └── introspector.go
│   │   │   │
│   │   │   ├── sqlite/                 # SQLite adapter
│   │   │   │   ├── adapter.go
│   │   │   │   ├── connection.go
│   │   │   │   ├── transaction.go
│   │   │   │   ├── types.go
│   │   │   │   └── introspector.go
│   │   │   │
│   │   │   └── factory.go              # Adapter factory
│   │   │
│   │   ├── storage/                     # Storage adapters
│   │   │   ├── interface.go            # Storage interface
│   │   │   ├── filesystem.go           # File system storage
│   │   │   ├── memory.go               # In-memory storage
│   │   │   └── factory.go              # Storage factory
│   │   │
│   │   └── telemetry/                   # Telemetry adapters
│   │       ├── interface.go            # Telemetry interface
│   │       ├── prometheus.go           # Prometheus metrics
│   │       ├── opentelemetry.go        # OpenTelemetry integration
│   │       └── noop.go                 # No-op implementation
│   │
│   ├── repository/                      # Repository Pattern (Data Access)
│   │   ├── interface.go                # Repository interfaces
│   │   ├── migration_repository.go     # Migration repository
│   │   ├── schema_repository.go        # Schema repository
│   │   ├── history_repository.go       # History repository
│   │   └── config_repository.go        # Config repository
│   │
│   ├── service/                         # Application Services (Use Cases)
│   │   ├── migration_service.go        # Migration orchestration
│   │   ├── generate_service.go         # Code generation orchestration
│   │   ├── introspect_service.go       # Introspection orchestration
│   │   ├── format_service.go           # Format orchestration
│   │   └── validate_service.go         # Validation orchestration
│   │
│   ├── config/                          # Configuration
│   │   ├── config.go                   # Main config
│   │   ├── loader.go                   # Config loader
│   │   ├── database.go                 # Database config
│   │   ├── generator.go                # Generator config
│   │   └── validator.go                # Config validator
│   │
│   └── utils/                           # Internal utilities
│       ├── logger/                      # Logging
│       │   ├── logger.go               # Logger interface
│       │   ├── console.go              # Console logger
│       │   └── file.go                 # File logger
│       │
│       ├── errors/                      # Error handling
│       │   ├── errors.go               # Error types
│       │   ├── codes.go                # Error codes
│       │   └── handler.go              # Error handler
│       │
│       ├── pool/                        # Connection pooling
│       │   ├── pool.go                 # Pool interface
│       │   └── generic.go              # Generic pool
│       │
│       └── container/                   # Dependency injection
│           ├── container.go            # DI container
│           └── builder.go              # Container builder
│
├── runtime/                             # Runtime client library (Generated code base)
│   ├── client.go                       # Base client
│   ├── transaction.go                  # Transaction support
│   ├── middleware.go                   # Middleware chain
│   ├── batch.go                        # Batch operations
│   ├── hooks.go                        # Lifecycle hooks
│   ├── context.go                      # Context handling
│   └── errors.go                       # Runtime errors
│
├── examples/                            # Example projects
│   ├── basic/                          # Basic usage example
│   │   ├── main.go
│   │   └── schema.prisma
│   │
│   ├── advanced/                       # Advanced features
│   │   ├── main.go
│   │   ├── schema.prisma
│   │   └── README.md
│   │
│   ├── migrations/                     # Migration examples
│   │   ├── main.go
│   │   └── migrations/
│   │
│   ├── plugins/                        # Plugin examples
│   │   ├── custom-generator/
│   │   └── README.md
│   │
│   └── middleware/                     # Middleware examples
│       ├── logging/
│       ├── metrics/
│       └── README.md
│
├── test/                               # Test infrastructure
│   ├── unit/                           # Unit tests (alongside code)
│   │   ├── schema/
│   │   ├── migration/
│   │   ├── query/
│   │   └── generator/
│   │
│   ├── integration/                    # Integration tests
│   │   ├── postgres/
│   │   │   ├── schema_test.go
│   │   │   ├── migration_test.go
│   │   │   └── query_test.go
│   │   │
│   │   ├── mysql/
│   │   │   ├── schema_test.go
│   │   │   ├── migration_test.go
│   │   │   └── query_test.go
│   │   │
│   │   └── sqlite/
│   │       ├── schema_test.go
│   │       ├── migration_test.go
│   │       └── query_test.go
│   │
│   ├── e2e/                            # End-to-end tests
│   │   ├── cli_test.go
│   │   ├── generate_test.go
│   │   └── migrate_test.go
│   │
│   ├── benchmark/                      # Benchmarks
│   │   ├── parser_bench_test.go
│   │   ├── query_bench_test.go
│   │   └── generator_bench_test.go
│   │
│   ├── fixtures/                       # Test fixtures
│   │   ├── schemas/
│   │   ├── migrations/
│   │   └── databases/
│   │
│   └── mocks/                          # Mock implementations
│       ├── database_mock.go
│       ├── repository_mock.go
│       └── service_mock.go
│
├── docs/                               # Documentation
│   ├── architecture/                   # Architecture docs
│   │   ├── overview.md
│   │   ├── layers.md
│   │   ├── dependencies.md
│   │   └── patterns.md
│   │
│   ├── guides/                         # User guides
│   │   ├── getting-started.md
│   │   ├── migrations.md
│   │   ├── queries.md
│   │   ├── plugins.md
│   │   └── best-practices.md
│   │
│   ├── api/                            # API reference
│   │   ├── client.md
│   │   ├── schema.md
│   │   ├── generator.md
│   │   └── middleware.md
│   │
│   └── development/                    # Development docs
│       ├── contributing.md
│       ├── testing.md
│       └── releasing.md
│
├── scripts/                            # Build and dev scripts
│   ├── build.sh                       # Build script
│   ├── test.sh                        # Test runner
│   ├── benchmark.sh                   # Benchmark runner
│   ├── generate-mocks.sh              # Mock generator
│   ├── lint.sh                        # Linter runner
│   └── release.sh                     # Release script
│
├── .github/                            # GitHub configuration
│   ├── workflows/                      # GitHub Actions
│   │   ├── ci.yml                     # CI pipeline
│   │   ├── release.yml                # Release automation
│   │   ├── docs.yml                   # Docs deployment
│   │   └── benchmark.yml              # Benchmark tracking
│   │
│   ├── ISSUE_TEMPLATE/
│   ├── PULL_REQUEST_TEMPLATE.md
│   └── CODEOWNERS
│
├── .golangci.yml                       # Linter configuration
├── .gitignore
├── go.mod
├── go.sum
├── Makefile                            # Make targets
├── README.md
├── ARCHITECTURE.md                     # Architecture documentation
├── CONTRIBUTING.md                     # Contributing guide
├── CHANGELOG.md                        # Changelog
└── LICENSE
```

---

## Core Interfaces & Contracts

### 1. Domain Layer Interfaces

#### Schema Domain

```go
// internal/core/schema/domain/schema.go
package domain

import "context"

// Schema represents the Prisma schema aggregate root
type Schema struct {
    Datasources []Datasource
    Generators  []Generator
    Models      []Model
    Enums       []Enum
}

// SchemaParser defines the interface for parsing schemas
type SchemaParser interface {
    Parse(ctx context.Context, content string) (*Schema, error)
    ParseFile(ctx context.Context, path string) (*Schema, error)
}

// SchemaValidator defines the interface for validating schemas
type SchemaValidator interface {
    Validate(ctx context.Context, schema *Schema) error
    ValidateModel(ctx context.Context, model *Model) error
    ValidateField(ctx context.Context, field *Field) error
    ValidateRelation(ctx context.Context, relation *Relation) error
}

// SchemaFormatter defines the interface for formatting schemas
type SchemaFormatter interface {
    Format(ctx context.Context, schema *Schema) (string, error)
    FormatFile(ctx context.Context, path string) error
}
```

```go
// internal/core/schema/domain/model.go
package domain

// Model represents a Prisma model entity
type Model struct {
    Name       string
    Fields     []Field
    Indexes    []Index
    Attributes []Attribute
    Comments   []string
}

// Field represents a model field value object
type Field struct {
    Name         string
    Type         FieldType
    IsRequired   bool
    IsList       bool
    IsUnique     bool
    DefaultValue interface{}
    Attributes   []Attribute
}

// FieldType represents field type information
type FieldType struct {
    Name      string
    IsBuiltin bool
    IsModel   bool
    IsEnum    bool
}

// Relation represents a relation value object
type Relation struct {
    Name           string
    FromModel      string
    ToModel        string
    FromFields     []string
    ToFields       []string
    RelationType   RelationType
    OnDelete       ReferentialAction
    OnUpdate       ReferentialAction
}

type RelationType string

const (
    OneToOne   RelationType = "OneToOne"
    OneToMany  RelationType = "OneToMany"
    ManyToMany RelationType = "ManyToMany"
)

type ReferentialAction string

const (
    Cascade    ReferentialAction = "Cascade"
    Restrict   ReferentialAction = "Restrict"
    NoAction   ReferentialAction = "NoAction"
    SetNull    ReferentialAction = "SetNull"
    SetDefault ReferentialAction = "SetDefault"
)
```

#### Migration Domain

```go
// internal/core/migration/domain/migration.go
package domain

import (
    "context"
    "time"
)

// Migration represents a migration aggregate root
type Migration struct {
    ID          string
    Name        string
    CreatedAt   time.Time
    AppliedAt   *time.Time
    Changes     []Change
    SQL         []string
    Checksum    string
    Status      MigrationStatus
}

type MigrationStatus string

const (
    Pending    MigrationStatus = "Pending"
    Applied    MigrationStatus = "Applied"
    Failed     MigrationStatus = "Failed"
    RolledBack MigrationStatus = "RolledBack"
)

// Introspector defines database introspection interface
type Introspector interface {
    IntrospectDatabase(ctx context.Context) (*DatabaseState, error)
    IntrospectTable(ctx context.Context, tableName string) (*Table, error)
    ListTables(ctx context.Context) ([]string, error)
}

// Differ defines schema comparison interface
type Differ interface {
    Compare(ctx context.Context, from, to *DatabaseState) ([]Change, error)
    CompareTables(ctx context.Context, from, to *Table) ([]Change, error)
    CompareColumns(ctx context.Context, from, to *Column) ([]Change, error)
}

// Planner defines migration planning interface
type Planner interface {
    CreatePlan(ctx context.Context, changes []Change) (*MigrationPlan, error)
    OptimizePlan(ctx context.Context, plan *MigrationPlan) (*MigrationPlan, error)
    ValidatePlan(ctx context.Context, plan *MigrationPlan) error
}

// Executor defines migration execution interface
type Executor interface {
    Execute(ctx context.Context, migration *Migration) error
    Rollback(ctx context.Context, migration *Migration) error
    ExecuteSQL(ctx context.Context, sql []string) error
}
```

```go
// internal/core/migration/domain/change.go
package domain

// Change represents a database schema change
type Change interface {
    Type() ChangeType
    Description() string
    ToSQL(dialect SQLDialect) ([]string, error)
    IsDestructive() bool
}

type ChangeType string

const (
    CreateTable     ChangeType = "CreateTable"
    DropTable       ChangeType = "DropTable"
    AlterTable      ChangeType = "AlterTable"
    AddColumn       ChangeType = "AddColumn"
    DropColumn      ChangeType = "DropColumn"
    AlterColumn     ChangeType = "AlterColumn"
    CreateIndex     ChangeType = "CreateIndex"
    DropIndex       ChangeType = "DropIndex"
    AddConstraint   ChangeType = "AddConstraint"
    DropConstraint  ChangeType = "DropConstraint"
)

type SQLDialect string

const (
    PostgreSQL SQLDialect = "postgres"
    MySQL      SQLDialect = "mysql"
    SQLite     SQLDialect = "sqlite"
)

// CreateTableChange represents table creation
type CreateTableChange struct {
    Table *Table
}

// DropTableChange represents table deletion
type DropTableChange struct {
    TableName string
}

// AddColumnChange represents adding a column
type AddColumnChange struct {
    TableName string
    Column    *Column
}

// DatabaseState represents current database state
type DatabaseState struct {
    Tables []Table
}

type Table struct {
    Name        string
    Columns     []Column
    Indexes     []Index
    Constraints []Constraint
}

type Column struct {
    Name         string
    Type         string
    IsNullable   bool
    DefaultValue interface{}
    IsPrimaryKey bool
    IsUnique     bool
}

type Index struct {
    Name    string
    Columns []string
    IsUnique bool
}

type Constraint struct {
    Name           string
    Type           ConstraintType
    Columns        []string
    ReferencedTable string
    ReferencedColumns []string
    OnDelete       ReferentialAction
    OnUpdate       ReferentialAction
}

type ConstraintType string

const (
    PrimaryKey  ConstraintType = "PrimaryKey"
    ForeignKey  ConstraintType = "ForeignKey"
    UniqueKey   ConstraintType = "UniqueKey"
    CheckKey    ConstraintType = "CheckKey"
)
```

#### Query Domain
```go
// internal/core/query/domain/query.go
package domain

import "context"

// Query represents a query aggregate root
type Query struct {
    Model      string
    Operation  QueryOperation
    Selection  Selection
    Filter     Filter
    Relations  []RelationInclusion
    Ordering   []OrderBy
    Pagination Pagination
}

type QueryOperation string

const (
    FindMany   QueryOperation = "FindMany"
    FindFirst  QueryOperation = "FindFirst"
    FindUnique QueryOperation = "FindUnique"
    Create     QueryOperation = "Create"
    CreateMany QueryOperation = "CreateMany"
    Update     QueryOperation = "Update"
    UpdateMany QueryOperation = "UpdateMany"
    Delete     QueryOperation = "Delete"
    DeleteMany QueryOperation = "DeleteMany"
    Upsert     QueryOperation = "Upsert"
    Aggregate  QueryOperation = "Aggregate"
)

// Selection defines what fields to return
type Selection struct {
    Fields   []string
    Include  bool // true = include, false = select
}

// Filter represents query conditions
type Filter struct {
    Conditions []Condition
    Operator   LogicalOperator
}

type LogicalOperator string

const (
    AND LogicalOperator = "AND"
    OR  LogicalOperator = "OR"
    NOT LogicalOperator = "NOT"
)

type Condition struct {
    Field    string
    Operator ComparisonOperator
    Value    interface{}
}

type ComparisonOperator string

const (
    Equals             ComparisonOperator = "equals"
    NotEquals          ComparisonOperator = "not"
    In                 ComparisonOperator = "in"
    NotIn              ComparisonOperator = "notIn"
    Lt                 ComparisonOperator = "lt"
    Lte                ComparisonOperator = "lte"
    Gt                 ComparisonOperator = "gt"
    Gte                ComparisonOperator = "gte"
    Contains           ComparisonOperator = "contains"
    StartsWith         ComparisonOperator = "startsWith"
    EndsWith           ComparisonOperator = "endsWith"
)

// RelationInclusion defines relation loading
type RelationInclusion struct {
    Relation string
    Query    *Query // Nested query
}

// OrderBy defines sorting
type OrderBy struct {
    Field     string
    Direction SortDirection
}

type SortDirection string

const (
    Asc  SortDirection = "asc"
    Desc SortDirection = "desc"
)

// Pagination defines result pagination
type Pagination struct {
    Skip *int
    Take *int
}

// QueryBuilder defines query building interface
type QueryBuilder interface {
    Build(ctx context.Context, query *Query) (SQL, error)
}

// QueryCompiler defines query compilation interface
type QueryCompiler interface {
    Compile(ctx context.Context, query *Query) (*CompiledQuery, error)
    Optimize(ctx context.Context, compiled *CompiledQuery) (*CompiledQuery, error)
}

// QueryExecutor defines query execution interface
type QueryExecutor interface {
    Execute(ctx context.Context, query *CompiledQuery) (interface{}, error)
    ExecuteBatch(ctx context.Context, queries []*CompiledQuery) ([]interface{}, error)
}

// SQL represents generated SQL
type SQL struct {
    Query      string
    Args       []interface{}
    Dialect    SQLDialect
}

// CompiledQuery represents a compiled query ready for execution
type CompiledQuery struct {
    SQL        SQL
    Mapping    ResultMapping
    CacheKey   string
}

// ResultMapping defines how to map results to Go types
type ResultMapping struct {
    Model      string
    Fields     []FieldMapping
    Relations  []RelationMapping
}

type FieldMapping struct {
    Field      string
    Column     string
    Type       string
}

type RelationMapping struct {
    Relation   string
    Type       RelationType
    Mapping    *ResultMapping
}
```

#### Generator Domain
```go
// internal/core/generator/domain/model.go
package domain

import "context"

// GeneratedModel represents a model to be generated
type GeneratedModel struct {
    Name       string
    Fields     []GeneratedField
    Methods    []GeneratedMethod
    Relations  []GeneratedRelation
}

// GeneratedField represents a field in the generated model
type GeneratedField struct {
    Name       string
    Type       string
    JSONTag    string
    DBTag      string
    IsPointer  bool
    IsSlice    bool
}

// GeneratedMethod represents a method in the generated client
type GeneratedMethod struct {
    Name       string
    Receiver   string
    Params     []Param
    Returns    []Return
    Body       string
}

type Param struct {
    Name string
    Type string
}

type Return struct {
    Type string
}

// GeneratedRelation represents a relation in the generated code
type GeneratedRelation struct {
    Name       string
    Type       RelationType
    Model      string
}

// Analyzer defines schema analysis interface
type Analyzer interface {
    Analyze(ctx context.Context, schema *Schema) (*AnalyzedSchema, error)
    AnalyzeModel(ctx context.Context, model *Model) (*GeneratedModel, error)
}

// TemplateEngine defines template rendering interface
type TemplateEngine interface {
    Render(ctx context.Context, template string, data interface{}) (string, error)
    RenderFile(ctx context.Context, templatePath string, data interface{}) (string, error)
}

// CodeWriter defines code writing interface
type CodeWriter interface {
    Write(ctx context.Context, files []GeneratedFile) error
    WriteFile(ctx context.Context, file GeneratedFile) error
    Format(ctx context.Context, code string) (string, error)
}

// GeneratedFile represents a generated file
type GeneratedFile struct {
    Path    string
    Content string
}

// AnalyzedSchema represents analyzed schema data
type AnalyzedSchema struct {
    Models     []GeneratedModel
    Enums      []GeneratedEnum
    Relations  []GeneratedRelation
    Config     GeneratorConfig
}

type GeneratedEnum struct {
    Name   string
    Values []string
}

type GeneratorConfig struct {
    Output   string
    Package  string
}
```

### 2. Repository Interfaces
```go
// internal/repository/interface.go
package repository

import "context"

// MigrationRepository defines migration data access
type MigrationRepository interface {
    // Save saves a migration
    Save(ctx context.Context, migration *domain.Migration) error
    
    // FindAll retrieves all migrations
    FindAll(ctx context.Context) ([]*domain.Migration, error)
    
    // FindByID retrieves a migration by ID
    FindByID(ctx context.Context, id string) (*domain.Migration, error)
    
    // FindPending retrieves pending migrations
    FindPending(ctx context.Context) ([]*domain.Migration, error)
    
    // FindApplied retrieves applied migrations
    FindApplied(ctx context.Context) ([]*domain.Migration, error)
    
    // MarkAsApplied marks a migration as applied
    MarkAsApplied(ctx context.Context, id string) error
    
    // Delete deletes a migration
    Delete(ctx context.Context, id string) error
}

// SchemaRepository defines schema data access
type SchemaRepository interface {
    // Load loads a schema from file
    Load(ctx context.Context, path string) (*domain.Schema, error)
    
    // Save saves a schema to file
    Save(ctx context.Context, path string, schema *domain.Schema) error
    
    // Validate validates a schema file exists
    Validate(ctx context.Context, path string) error
}

// HistoryRepository defines migration history data access
type HistoryRepository interface {
    // Record records a migration in history
    Record(ctx context.Context, migration *domain.Migration) error
    
    // GetHistory retrieves migration history
    GetHistory(ctx context.Context) ([]*domain.Migration, error)
    
    // GetLastApplied retrieves the last applied migration
    GetLastApplied(ctx context.Context) (*domain.Migration, error)
}

// ConfigRepository defines configuration data access
type ConfigRepository interface {
    // Load loads configuration
    Load(ctx context.Context) (*config.Config, error)
    
    // Save saves configuration
    Save(ctx context.Context, cfg *config.Config) error
}
```

### 3. Service Interfaces (Use Cases)
```go
// internal/service/migration_service.go
package service

import (
    "context"
    "github.com/satishbabariya/prisma-go/internal/core/migration/domain"
    "github.com/satishbabariya/prisma-go/internal/repository"
)

// MigrationService orchestrates migration operations
type MigrationService struct {
    schemaRepo     repository.SchemaRepository
    migrationRepo  repository.MigrationRepository
    historyRepo    repository.HistoryRepository
    introspector   domain.Introspector
    differ         domain.Differ
    planner        domain.Planner
    executor       domain.Executor
}

// NewMigrationService creates a new migration service
func NewMigrationService(
    schemaRepo repository.SchemaRepository,
    migrationRepo repository.MigrationRepository,
    historyRepo repository.HistoryRepository,
    introspector domain.Introspector,
    differ domain.Differ,
    planner domain.Planner,
    executor domain.Executor,
) *MigrationService {
    return &MigrationService{
        schemaRepo:    schemaRepo,
        migrationRepo: migrationRepo,
        historyRepo:   historyRepo,
        introspector:  introspector,
        differ:        differ,
        planner:       planner,
        executor:      executor,
    }
}

// CreateMigration creates a new migration
func (s *MigrationService) CreateMigration(ctx context.Context, input CreateMigrationInput) (*domain.Migration, error) {
    // 1. Load schema
    schema, err := s.schemaRepo.Load(ctx, input.SchemaPath)
    if err != nil {
        return nil, err
    }

    // 2. Introspect database
    dbState, err := s.introspector.IntrospectDatabase(ctx)
    if err != nil {
        return nil, err
    }

    // 3. Compare schema with database
    changes, err := s.differ.Compare(ctx, dbState, schema.ToDatabase())
    if err != nil {
        return nil, err
    }

    // 4. Create migration plan
    plan, err := s.planner.CreatePlan(ctx, changes)
    if err != nil {
        return nil, err
    }

    // 5. Generate migration
    migration := domain.NewMigration(input.Name, plan.SQL, changes)

    // 6. Save migration
    if err := s.migrationRepo.Save(ctx, migration); err != nil {
        return nil, err
    }

    return migration, nil
}

// ApplyMigration applies a migration
func (s *MigrationService) ApplyMigration(ctx context.Context, migrationID string) error {
    // 1. Load migration
    migration, err := s.migrationRepo.FindByID(ctx, migrationID)
    if err != nil {
        return err
    }

    // 2. Execute migration
    if err := s.executor.Execute(ctx, migration); err != nil {
        return err
    }

    // 3. Mark as applied
    if err := s.migrationRepo.MarkAsApplied(ctx, migrationID); err != nil {
        return err
    }

    // 4. Record in history
    if err := s.historyRepo.Record(ctx, migration); err != nil {
        return err
    }

    return nil
}

// RollbackMigration rolls back a migration
func (s *MigrationService) RollbackMigration(ctx context.Context, migrationID string) error {
    migration, err := s.migrationRepo.FindByID(ctx, migrationID)
    if err != nil {
        return err
    }

    return s.executor.Rollback(ctx, migration)
}

// GetMigrationStatus gets migration status
func (s *MigrationService) GetMigrationStatus(ctx context.Context) (*MigrationStatus, error) {
    pending, err := s.migrationRepo.FindPending(ctx)
    if err != nil {
        return nil, err
    }

    applied, err := s.migrationRepo.FindApplied(ctx)
    if err != nil {
        return nil, err
    }

    return &MigrationStatus{
        Pending: pending,
        Applied: applied,
    }, nil
}

type CreateMigrationInput struct {
    Name       string
    SchemaPath string
}

type MigrationStatus struct {
    Pending []*domain.Migration
    Applied []*domain.Migration
}
```
```go
// internal/service/generate_service.go
package service

import (
    "context"
    "github.com/satishbabariya/prisma-go/internal/core/generator/domain"
    "github.com/satishbabariya/prisma-go/internal/repository"
)

// GenerateService orchestrates code generation
type GenerateService struct {
    schemaRepo repository.SchemaRepository
    analyzer   domain.Analyzer
    engine     domain.TemplateEngine
    writer     domain.CodeWriter
}

// NewGenerateService creates a new generate service
func NewGenerateService(
    schemaRepo repository.SchemaRepository,
    analyzer domain.Analyzer,
    engine domain.TemplateEngine,
    writer domain.CodeWriter,
) *GenerateService {
    return &GenerateService{
        schemaRepo: schemaRepo,
        analyzer:   analyzer,
        engine:     engine,
        writer:     writer,
    }
}

// Generate generates code from schema
func (s *GenerateService) Generate(ctx context.Context, input GenerateInput) error {
    // 1. Load schema
    schema, err := s.schemaRepo.Load(ctx, input.SchemaPath)
    if err != nil {
        return err
    }

    // 2. Analyze schema
    analyzed, err := s.analyzer.Analyze(ctx, schema)
    if err != nil {
        return err
    }

    // 3. Generate files
    files := []domain.GeneratedFile{}
    
    // Generate client
    clientCode, err := s.engine.Render(ctx, "client.tmpl", analyzed)
    if err != nil {
        return err
    }
    files = append(files, domain.GeneratedFile{
        Path:    "client.go",
        Content: clientCode,
    })

    // Generate models
    for _, model := range analyzed.Models {
        modelCode, err := s.engine.Render(ctx, "model.tmpl", model)
        if err != nil {
            return err
        }
        files = append(files, domain.GeneratedFile{
            Path:    model.Name + ".go",
            Content: modelCode,
        })
    }

    // 4. Write files
    if err := s.writer.Write(ctx, files); err != nil {
        return err
    }

    return nil
}

type GenerateInput struct {
    SchemaPath string
    Output     string
}
```

### 4. Database Adapter Interface
```go
// internal/adapters/database/interface.go
package database

import (
    "context"
    "database/sql"
)

// Adapter defines the database adapter interface
type Adapter interface {
    // Connect establishes a database connection
    Connect(ctx context.Context) error
    
    // Disconnect closes the database connection
    Disconnect(ctx context.Context) error
    
    // Execute executes a SQL statement
    Execute(ctx context.Context, query string, args ...interface{}) (sql.Result, error)
    
    // Query executes a query that returns rows
    Query(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)
    
    // QueryRow executes a query that returns a single row
    QueryRow(ctx context.Context, query string, args ...interface{}) *sql.Row
    
    // Begin starts a transaction
    Begin(ctx context.Context) (Transaction, error)
    
    // Ping checks the database connection
    Ping(ctx context.Context) error
    
    // GetDialect returns the SQL dialect
    GetDialect() SQLDialect
}

// Transaction defines the transaction interface
type Transaction interface {
    // Commit commits the transaction
    Commit() error
    
    // Rollback rolls back the transaction
    Rollback() error
    
    // Execute executes a statement within the transaction
    Execute(ctx context.Context, query string, args ...interface{}) (sql.Result, error)
    
    // Query executes a query within the transaction
    Query(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)
}

// ConnectionConfig defines database connection configuration
type ConnectionConfig struct {
    URL            string
    MaxConnections int
    MaxIdleTime    int
    ConnectTimeout int
}
```

### 5. Public Client API
```go
// pkg/client/client.go
package client

import "context"

// Client is the main Prisma client interface
type Client interface {
    // Connect establishes a connection to the database
    Connect(ctx context.Context) error
    
    // Disconnect closes the database connection
    Disconnect(ctx context.Context) error
    
    // Transaction executes a function within a transaction
    Transaction(fn func(tx Transaction) error) error
    
    // Use adds a middleware to the client
    Use(middleware Middleware)
    
    // Raw executes raw SQL
    Raw(ctx context.Context, query string, args ...interface{}) (interface{}, error)
}

// Transaction represents a database transaction
type Transaction interface {
    // Commit commits the transaction
    Commit() error
    
    // Rollback rolls back the transaction
    Rollback() error
}

// Middleware defines the middleware function signature
type Middleware func(next QueryFunc) QueryFunc

// QueryFunc is the function signature for query execution
type QueryFunc func(ctx context.Context, query string, args ...interface{}) (interface{}, error)

// Options defines client configuration options
type Options struct {
    DatabaseURL    string
    MaxConnections int
    Middleware     []Middleware
    Logger         Logger
}

// Logger defines the logging interface
type Logger interface {
    Debug(msg string, fields ...Field)
    Info(msg string, fields ...Field)
    Warn(msg string, fields ...Field)
    Error(msg string, fields ...Field)
}

type Field struct {
    Key   string
    Value interface{}
}
```

---

## Implementation Examples

### Example 1: Complete Migration Flow
```go
// cmd/prisma/commands/migrate.go
package commands

import (
    "context"
    "fmt"

    "github.com/satishbabariya/prisma-go/internal/service"
    "github.com/satishbabariya/prisma-go/internal/utils/logger"
)

// MigrateDevCommand handles the migrate dev command
type MigrateDevCommand struct {
    migrationService *service.MigrationService
    logger           logger.Logger
}

// Execute runs the migrate dev command
func (c *MigrateDevCommand) Execute(ctx context.Context, args Args) error {
    c.logger.Info("Creating migration...")

    // Create migration
    migration, err := c.migrationService.CreateMigration(ctx, service.CreateMigrationInput{
        Name:       args.Name,
        SchemaPath: args.SchemaPath,
    })
    if err != nil {
        return fmt.Errorf("failed to create migration: %w", err)
    }

    c.logger.Info("Migration created", logger.Field{Key: "id", Value: migration.ID})

    // Auto-apply if requested
    if args.Apply {
        c.logger.Info("Applying migration...")
        
        if err := c.migrationService.ApplyMigration(ctx, migration.ID); err != nil {
            return fmt.Errorf("failed to apply migration: %w", err)
        }

        c.logger.Info("Migration applied successfully")
    }

    return nil
}

type Args struct {
    Name       string
    SchemaPath string
    Apply      bool
}
```

### Example 2: Database Adapter Implementation
```go
// internal/adapters/database/postgres/adapter.go
package postgres

import (
    "context"
    "database/sql"
    "fmt"

    _ "github.com/lib/pq"
    "github.com/satishbabariya/prisma-go/internal/adapters/database"
)

// Adapter implements the database adapter for PostgreSQL
type Adapter struct {
    db     *sql.DB
    config database.ConnectionConfig
}

// NewAdapter creates a new PostgreSQL adapter
func NewAdapter(config database.ConnectionConfig) *Adapter {
    return &Adapter{
        config: config,
    }
}

// Connect establishes a connection to PostgreSQL
func (a *Adapter) Connect(ctx context.Context) error {
    db, err := sql.Open("postgres", a.config.URL)
    if err != nil {
        return fmt.Errorf("failed to open connection: %w", err)
    }

    db.SetMaxOpenConns(a.config.MaxConnections)
    db.SetMaxIdleConns(a.config.MaxConnections / 2)

    if err := db.PingContext(ctx); err != nil {
        return fmt.Errorf("failed to ping database: %w", err)
    }

    a.db = db
    return nil
}

// Disconnect closes the database connection
func (a *Adapter) Disconnect(ctx context.Context) error {
    if a.db != nil {
        return a.db.Close()
    }
    return nil
}

// Execute executes a SQL statement
func (a *Adapter) Execute(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
    return a.db.ExecContext(ctx, query, args...)
}

// Query executes a query that returns rows
func (a *Adapter) Query(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
    return a.db.QueryContext(ctx, query, args...)
}

// QueryRow executes a query that returns a single row
func (a *Adapter) QueryRow(ctx context.Context, query string, args ...interface{}) *sql.Row {
    return a.db.QueryRowContext(ctx, query, args...)
}

// Begin starts a transaction
func (a *Adapter) Begin(ctx context.Context) (database.Transaction, error) {
    tx, err := a.db.BeginTx(ctx, nil)
    if err != nil {
        return nil, err
    }
    return &Transaction{tx: tx}, nil
}

// Ping checks the database connection
func (a *Adapter) Ping(ctx context.Context) error {
    return a.db.PingContext(ctx)
}

// GetDialect returns the SQL dialect
func (a *Adapter) GetDialect() database.SQLDialect {
    return database.PostgreSQL
}

// Transaction implements the transaction interface
type Transaction struct {
    tx *sql.Tx
}

func (t *Transaction) Commit() error {
    return t.tx.Commit()
}

func (t *Transaction) Rollback() error {
    return t.tx.Rollback()
}

func (t *Transaction) Execute(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
    return t.tx.ExecContext(ctx, query, args...)
}

func (t *Transaction) Query(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
    return t.tx.QueryContext(ctx, query, args...)
}
```

### Example 3: Repository Implementation
```go
// internal/repository/migration_repository.go
package repository

import (
    "context"
    "encoding/json"
    "fmt"

    "github.com/satishbabariya/prisma-go/internal/adapters/database"
    "github.com/satishbabariya/prisma-go/internal/core/migration/domain"
)

// migrationRepository implements MigrationRepository
type migrationRepository struct {
    db database.Adapter
}

// NewMigrationRepository creates a new migration repository
func NewMigrationRepository(db database.Adapter) MigrationRepository {
    return &migrationRepository{db: db}
}

// Save saves a migration
func (r *migrationRepository) Save(ctx context.Context, migration *domain.Migration) error {
    changesJSON, err := json.Marshal(migration.Changes)
    if err != nil {
        return fmt.Errorf("failed to marshal changes: %w", err)
    }

    sqlJSON, err := json.Marshal(migration.SQL)
    if err != nil {
        return fmt.Errorf("failed to marshal SQL: %w", err)
    }

    query := `
        INSERT INTO _prisma_migrations (id, name, created_at, changes, sql, checksum, status)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
    `

    _, err = r.db.Execute(ctx, query,
        migration.ID,
        migration.Name,
        migration.CreatedAt,
        changesJSON,
        sqlJSON,
        migration.Checksum,
        migration.Status,
    )

    return err
}

// FindAll retrieves all migrations
func (r *migrationRepository) FindAll(ctx context.Context) ([]*domain.Migration, error) {
    query := `
        SELECT id, name, created_at, applied_at, changes, sql, checksum, status
        FROM _prisma_migrations
        ORDER BY created_at ASC
    `

    rows, err := r.db.Query(ctx, query)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    migrations := []*domain.Migration{}
    for rows.Next() {
        migration := &domain.Migration{}
        var changesJSON, sqlJSON []byte

        err := rows.Scan(
            &migration.ID,
            &migration.Name,
            &migration.CreatedAt,
            &migration.AppliedAt,
            &changesJSON,
            &sqlJSON,
            &migration.Checksum,
            &migration.Status,
        )
        if err != nil {
            return nil, err
        }

        if err := json.Unmarshal(changesJSON, &migration.Changes); err != nil {
            return nil, err
        }

        if err := json.Unmarshal(sqlJSON, &migration.SQL); err != nil {
            return nil, err
        }

        migrations = append(migrations, migration)
    }

    return migrations, nil
}

// FindByID retrieves a migration by ID
func (r *migrationRepository) FindByID(ctx context.Context, id string) (*domain.Migration, error) {
    query := `
        SELECT id, name, created_at, applied_at, changes, sql, checksum, status
        FROM _prisma_migrations
        WHERE id = $1
    `

    migration := &domain.Migration{}
    var changesJSON, sqlJSON []byte

    row := r.db.QueryRow(ctx, query, id)
    err := row.Scan(
        &migration.ID,
        &migration.Name,
        &migration.CreatedAt,
        &migration.AppliedAt,
        &changesJSON,
        &sqlJSON,
        &migration.Checksum,
        &migration.Status,
    )
    if err != nil {
        return nil, err
    }

    if err := json.Unmarshal(changesJSON, &migration.Changes); err != nil {
        return nil, err
    }

    if err := json.Unmarshal(sqlJSON, &migration.SQL); err != nil {
        return nil, err
    }

    return migration, nil
}

// FindPending retrieves pending migrations
func (r *migrationRepository) FindPending(ctx context.Context) ([]*domain.Migration, error) {
    query := `
        SELECT id, name, created_at, applied_at, changes, sql, checksum, status
        FROM _prisma_migrations
        WHERE status = $1
        ORDER BY created_at ASC
    `

    rows, err := r.db.Query(ctx, query, domain.Pending)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    migrations := []*domain.Migration{}
    for rows.Next() {
        migration := &domain.Migration{}
        var changesJSON, sqlJSON []byte

        err := rows.Scan(
            &migration.ID,
            &migration.Name,
            &migration.CreatedAt,
            &migration.AppliedAt,
            &changesJSON,
            &sqlJSON,
            &migration.Checksum,
            &migration.Status,
        )
        if err != nil {
            return nil, err
        }

        if err := json.Unmarshal(changesJSON, &migration.Changes); err != nil {
            return nil, err
        }

        if err := json.Unmarshal(sqlJSON, &migration.SQL); err != nil {
            return nil, err
        }

        migrations = append(migrations, migration)
    }

    return migrations, nil
}

// FindApplied retrieves applied migrations
func (r *migrationRepository) FindApplied(ctx context.Context) ([]*domain.Migration, error) {
    query := `
        SELECT id, name, created_at, applied_at, changes, sql, checksum, status
        FROM _prisma_migrations
        WHERE status = $1
        ORDER BY created_at ASC
    `

    rows, err := r.db.Query(ctx, query, domain.Applied)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    migrations := []*domain.Migration{}
    for rows.Next() {
        migration := &domain.Migration{}
        var changesJSON, sqlJSON []byte

        err := rows.Scan(
            &migration.ID,
            &migration.Name,
            &migration.CreatedAt,
            &migration.AppliedAt,
            &changesJSON,
            &sqlJSON,
            &migration.Checksum,
            &migration.Status,
        )
        if err != nil {
            return nil, err
        }

        if err := json.Unmarshal(changesJSON, &migration.Changes); err != nil {
            return nil, err
        }

        if err := json.Unmarshal(sqlJSON, &migration.SQL); err != nil {
            return nil, err
        }

        migrations = append(migrations, migration)
    }

    return migrations, nil
}

// MarkAsApplied marks a migration as applied
func (r *migrationRepository) MarkAsApplied(ctx context.Context, id string) error {
    query := `
        UPDATE _prisma_migrations
        SET status = $1, applied_at = NOW()
        WHERE id = $2
    `
    _, err := r.db.Execute(ctx, query, domain.Applied, id)
    return err
}

// Delete deletes a migration
func (r *migrationRepository) Delete(ctx context.Context, id string) error {
    query := `DELETE FROM _prisma_migrations WHERE id = $1`
    _, err := r.db.Execute(ctx, query, id)
    return err
}
```

### Example 4: Dependency Injection Container
```go
// cmd/prisma/container.go
package main

import (
    "context"
    "fmt"

    "github.com/satishbabariya/prisma-go/internal/adapters/database"
    "github.com/satishbabariya/prisma-go/internal/adapters/database/postgres"
    "github.com/satishbabariya/prisma-go/internal/config"
    "github.com/satishbabariya/prisma-go/internal/core/migration/differ"
    "github.com/satishbabariya/prisma-go/internal/core/migration/executor"
    "github.com/satishbabariya/prisma-go/internal/core/migration/introspector"
    "github.com/satishbabariya/prisma-go/internal/core/migration/planner"
    "github.com/satishbabariya/prisma-go/internal/repository"
    "github.com/satishbabariya/prisma-go/internal/service"
    "github.com/satishbabariya/prisma-go/internal/utils/logger"
)

// Container holds all dependencies
type Container struct {
    // Config
    config *config.Config

    // Infrastructure
    dbAdapter database.Adapter
    logger    logger.Logger

    // Repositories
    schemaRepo    repository.SchemaRepository
    migrationRepo repository.MigrationRepository
    historyRepo   repository.HistoryRepository

    // Core components
    introspector domain.Introspector
    differ       domain.Differ
    planner      domain.Planner
    executor     domain.Executor

    // Services
    migrationService *service.MigrationService
    generateService  *service.GenerateService
}

// NewContainer creates a new dependency injection container
func NewContainer(ctx context.Context, cfg *config.Config) (*Container, error) {
    c := &Container{
        config: cfg,
    }

    // Initialize logger
    c.logger = logger.NewConsoleLogger()

    // Initialize database adapter
    dbAdapter, err := createDatabaseAdapter(cfg.Database)
    if err != nil {
        return nil, fmt.Errorf("failed to create database adapter: %w", err)
    }
    c.dbAdapter = dbAdapter

    // Connect to database
    if err := c.dbAdapter.Connect(ctx); err != nil {
        return nil, fmt.Errorf("failed to connect to database: %w", err)
    }

    // Initialize repositories
    c.schemaRepo = repository.NewSchemaRepository()
    c.migrationRepo = repository.NewMigrationRepository(c.dbAdapter)
    c.historyRepo = repository.NewHistoryRepository(c.dbAdapter)

    // Initialize core components
    c.introspector = introspector.NewPostgresIntrospector(c.dbAdapter)
    c.differ = differ.NewDiffer()
    c.planner = planner.NewPlanner()
    c.executor = executor.NewExecutor(c.dbAdapter)

    // Initialize services
    c.migrationService = service.NewMigrationService(
        c.schemaRepo,
        c.migrationRepo,
        c.historyRepo,
        c.introspector,
        c.differ,
        c.planner,
        c.executor,
    )

    c.generateService = service.NewGenerateService(
        c.schemaRepo,
        analyzer.NewAnalyzer(),
        template.NewEngine(),
        writer.NewWriter(),
    )

    return c, nil
}

// Close closes all resources
func (c *Container) Close(ctx context.Context) error {
    return c.dbAdapter.Disconnect(ctx)
}

// createDatabaseAdapter creates the appropriate database adapter
func createDatabaseAdapter(cfg config.DatabaseConfig) (database.Adapter, error) {
    connConfig := database.ConnectionConfig{
        URL:            cfg.URL,
        MaxConnections: cfg.MaxConnections,
    }

    switch cfg.Provider {
    case "postgresql":
        return postgres.NewAdapter(connConfig), nil
    case "mysql":
        return mysql.NewAdapter(connConfig), nil
    case "sqlite":
        return sqlite.NewAdapter(connConfig), nil
    default:
        return nil, fmt.Errorf("unsupported database provider: %s", cfg.Provider)
    }
}
```

### Example 5: Middleware System
```go
// runtime/middleware.go
package runtime

import (
    "context"
    "fmt"
    "time"
)

// LoggingMiddleware logs all queries
func LoggingMiddleware(logger Logger) Middleware {
    return func(next QueryFunc) QueryFunc {
        return func(ctx context.Context, query string, args ...interface{}) (interface{}, error) {
            logger.Debug("Executing query",
                Field{Key: "query", Value: query},
                Field{Key: "args", Value: args},
            )

            result, err := next(ctx, query, args...)

            if err != nil {
                logger.Error("Query failed",
                    Field{Key: "query", Value: query},
                    Field{Key: "error", Value: err},
                )
            } else {
                logger.Debug("Query succeeded",
                    Field{Key: "query", Value: query},
                )
            }

            return result, err
        }
    }
}

// MetricsMiddleware records query metrics
func MetricsMiddleware(recorder MetricsRecorder) Middleware {
    return func(next QueryFunc) QueryFunc {
        return func(ctx context.Context, query string, args ...interface{}) (interface{}, error) {
            start := time.Now()

            result, err := next(ctx, query, args...)

            duration := time.Since(start)
            recorder.RecordQueryDuration(duration)

            if err != nil {
                recorder.RecordQueryError()
            } else {
                recorder.RecordQuerySuccess()
            }

            return result, err
        }
    }
}

// CachingMiddleware implements query caching
func CachingMiddleware(cache QueryCache) Middleware {
    return func(next QueryFunc) QueryFunc {
        return func(ctx context.Context, query string, args ...interface{}) (interface{}, error) {
            // Generate cache key
            cacheKey := generateCacheKey(query, args...)

            // Check cache
            if cachedResult, found := cache.Get(cacheKey); found {
                return cachedResult, nil
            }

            // Execute query
            result, err := next(ctx, query, args...)
            if err != nil {
                return nil, err
            }

            // Cache result
            cache.Set(cacheKey, result, 5*time.Minute)

            return result, nil
        }
    }
}

type MetricsRecorder interface {
    RecordQueryDuration(duration time.Duration)
    RecordQuerySuccess()
    RecordQueryError()
}

type QueryCache interface {
    Get(key string) (interface{}, bool)
    Set(key string, value interface{}, ttl time.Duration)
}

func generateCacheKey(query string, args ...interface{}) string {
    // Simple cache key generation (should use proper hashing in production)
    return fmt.Sprintf("%s:%v", query, args)
}
```

---

## Migration Strategy

### Phase 1: Setup (Week 1)

**Tasks:**
1. Create new directory structure
2. Set up build system (Makefile)
3. Configure CI/CD (GitHub Actions)
4. Initialize documentation

**Commands:**
```bash
# Create directory structure
./scripts/create-structure.sh

# Initialize modules
go mod tidy

# Run initial build
make build

# Run tests
make test
```

### Phase 2: Core Refactoring (Weeks 2-4)

**Step 1: Extract Domain Models**
```bash
# Move existing schema types to domain layer
mv psl/types.go internal/core/schema/domain/
mv migrate/types.go internal/core/migration/domain/
mv query/types.go internal/core/query/domain/
```

**Step 2: Create Interfaces**
```bash
# Create interface files
touch internal/core/schema/domain/interfaces.go
touch internal/core/migration/domain/interfaces.go
touch internal/core/query/domain/interfaces.go
```

**Step 3: Implement Repository Pattern**
```bash
# Create repository implementations
touch internal/repository/migration_repository.go
touch internal/repository/schema_repository.go
```

**Step 4: Create Service Layer**
```bash
# Create service implementations
touch internal/service/migration_service.go
touch internal/service/generate_service.go
```

### Phase 3: Testing (Weeks 5-6)

**Set up test infrastructure:**
```bash
# Create test directories
mkdir -p test/{unit,integration,e2e,benchmark}

# Create test helpers
touch test/helpers/database.go
touch test/helpers/fixtures.go

# Run tests
make test
make test-integration
make benchmark
```

### Phase 4: Documentation (Week 7)

**Create comprehensive documentation:**
```bash
# Generate documentation
make docs

# Create examples
./scripts/generate-examples.sh
```

### Phase 5: Release (Week 8)

**Prepare for release:**
```bash
# Tag version
git tag v2.0.0

# Build release artifacts
make build-release

# Publish
./scripts/publish.sh
```

---

## Testing Strategy

### Unit Tests
```go
// test/unit/migration/differ_test.go
package migration_test

import (
    "context"
    "testing"

    "github.com/satishbabariya/prisma-go/internal/core/migration/differ"
    "github.com/satishbabariya/prisma-go/internal/core/migration/domain"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestDiffer_CompareTables(t *testing.T) {
    tests := []struct {
        name     string
        from     *domain.Table
        to       *domain.Table
        expected []domain.Change
    }{
        {
            name: "detect new column",
            from: &domain.Table{
                Name: "users",
                Columns: []domain.Column{
                    {Name: "id", Type: "int"},
                },
            },
            to: &domain.Table{
                Name: "users",
                Columns: []domain.Column{
                    {Name: "id", Type: "int"},
                    {Name: "email", Type: "varchar"},
                },
            },
            expected: []domain.Change{
                &domain.AddColumnChange{
                    TableName: "users",
                    Column: &domain.Column{
                        Name: "email",
                        Type: "varchar",
                    },
                },
            },
        },
        // More test cases...
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            d := differ.NewDiffer()
            changes, err := d.CompareTables(context.Background(), tt.from, tt.to)
            
            require.NoError(t, err)
            assert.Equal(t, tt.expected, changes)
        })
    }
}
```

### Integration Tests
```go
// test/integration/postgres/migration_test.go
// +build integration

package postgres_test

import (
    "context"
    "testing"

    "github.com/satishbabariya/prisma-go/test/helpers"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestMigration_CreateAndApply(t *testing.T) {
    // Set up test database
    db := helpers.SetupTestDatabase(t)
    defer db.Teardown()

    // Create container with dependencies
    container := helpers.CreateTestContainer(t, db.ConnectionString())

    // Create migration
    migration, err := container.MigrationService.CreateMigration(
        context.Background(),
        service.CreateMigrationInput{
            Name:       "init",
            SchemaPath: "testdata/schema.prisma",
        },
    )
    require.NoError(t, err)
    assert.NotNil(t, migration)

    // Apply migration
    err = container.MigrationService.ApplyMigration(
        context.Background(),
        migration.ID,
    )
    require.NoError(t, err)

    // Verify tables were created
    tables, err := db.ListTables(context.Background())
    require.NoError(t, err)
    assert.Contains(t, tables, "users")
}
```

### Benchmark Tests
```go
// test/benchmark/query_bench_test.go
package benchmark_test

import (
    "context"
    "testing"

    "github.com/satishbabariya/prisma-go/internal/core/query/builder"
)

func BenchmarkQueryBuilder(b *testing.B) {
    qb := builder.NewSelectBuilder()

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _, _, err := qb.
            Select("id", "name", "email").
            From("users").
            Where("age > ?", 18).
            Build()
        
        if err != nil {
            b.Fatal(err)
        }
    }
}

func BenchmarkQueryExecutor(b *testing.B) {
    // Benchmark query execution with various scenarios
}
```

---

## Build & Development

### Makefile
```makefile
# Variables
BINARY_NAME=prisma
BUILD_DIR=bin
GO=go
GOFLAGS=-v
LDFLAGS=-ldflags="-s -w"

.PHONY: all build test lint fmt clean install generate-mocks

# Default target
all: build

# Build the binary
build:
	@echo "Building $(BINARY_NAME)..."
	@$(GO) build $(GOFLAGS) $(LDFLAGS) -o $(BUILD_DIR)/$(BINARY_NAME) ./cmd/prisma

# Build for multiple platforms
build-release:
	@echo "Building for multiple platforms..."
	@GOOS=linux GOARCH=amd64 $(GO) build $(LDFLAGS) -o $(BUILD_DIR)/$(BINARY_NAME)-linux-amd64 ./cmd/prisma
	@GOOS=darwin GOARCH=amd64 $(GO) build $(LDFLAGS) -o $(BUILD_DIR)/$(BINARY_NAME)-darwin-amd64 ./cmd/prisma
	@GOOS=darwin GOARCH=arm64 $(GO) build $(LDFLAGS) -o $(BUILD_DIR)/$(BINARY_NAME)-darwin-arm64 ./cmd/prisma
	@GOOS=windows GOARCH=amd64 $(GO) build $(LDFLAGS) -o $(BUILD_DIR)/$(BINARY_NAME)-windows-amd64.exe ./cmd/prisma

# Run tests
test:
	@echo "Running unit tests..."
	@$(GO) test -v -race -coverprofile=coverage.out ./...

# Run integration tests
test-integration:
	@echo "Running integration tests..."
	@$(GO) test -v -tags=integration ./test/integration/...

# Run E2E tests
test-e2e:
	@echo "Running E2E tests..."
	@$(GO) test -v ./test/e2e/...

# Run benchmarks
benchmark:
	@echo "Running benchmarks..."
	@$(GO) test -bench=. -benchmem ./test/benchmark/...

# Run linter
lint:
	@echo "Running linter..."
	@golangci-lint run

# Format code
fmt:
	@echo "Formatting code..."
	@gofmt -s -w .
	@goimports -w .

# Install the binary
install:
	@echo "Installing $(BINARY_NAME)..."
	@$(GO) install ./cmd/prisma

# Generate mocks
generate-mocks:
	@echo "Generating mocks..."
	@mockgen -source=internal/core/migration/domain/interfaces.go -destination=test/mocks/migration_mock.go
	@mockgen -source=internal/repository/interface.go -destination=test/mocks/repository_mock.go

# Generate documentation
docs:
	@echo "Generating documentation..."
	@godoc -http=:6060

# Clean build artifacts
clean:
	@echo "Cleaning..."
	@rm -rf $(BUILD_DIR)
	@rm -f coverage.out

# Show help
help:
	@echo "Available targets:"
	@echo "  build            - Build the binary"
	@echo "  build-release    - Build for multiple platforms"
	@echo "  test             - Run unit tests"
	@echo "  test-integration - Run integration tests"
	@echo "  test-e2e         - Run E2E tests"
	@echo "  benchmark        - Run benchmarks"
	@echo "  lint             - Run linter"
	@echo "  fmt              - Format code"
	@echo "  install          - Install the binary"
	@echo "  generate-mocks   - Generate mocks"
	@echo "  docs             - Generate documentation"
	@echo "  clean            - Clean build artifacts"
	@echo "  help             - Show this help message"

.DEFAULT_GOAL := help
```

### GitHub Actions CI/CD
```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        go-version: [1.21, 1.22, 1.23]

    steps:
      - uses: actions/checkout@v3

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ matrix.go-version }}

      - name: Cache Go modules
        uses: actions/cache@v3
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Install dependencies
        run: go mod download

      - name: Run linter
        uses: golangci/golangci-lint-action@v3
        with:
          version: latest

      - name: Run tests
        run: make test

      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage.out

  integration-test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - uses: actions/checkout@v3

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: 1.23

      - name: Run integration tests
        run: make test-integration
        env:
          DATABASE_URL: postgres://postgres:postgres@localhost:5432/test?sslmode=disable

  benchmark:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: 1.23

      - name: Run benchmarks
        run: make benchmark

      - name: Store benchmark result
        uses: benchmark-action/github-action-benchmark@v1
        with:
          tool: 'go'
          output-file-path: benchmark.txt
          github-token: ${{ secrets.GITHUB_TOKEN}}
          auto-push: true
```

---

## Documentation Requirements

### 1. Architecture Documentation

**File: `ARCHITECTURE.md`**
- Clean Architecture overview
- Layer responsibilities
- Dependency rules
- Component interactions
- Design patterns used

### 2. API Reference

**File: `docs/api/client.md`**
- Client API documentation
- All public methods
- Code examples
- Error handling

### 3. User Guides

**Files:**
- `docs/guides/getting-started.md` - Quick start guide
- `docs/guides/migrations.md` - Migration guide
- `docs/guides/queries.md` - Query guide
- `docs/guides/plugins.md` - Plugin development

### 4. Development Guide

**File: `CONTRIBUTING.md`**
- Setup development environment
- Code style guidelines
- Testing requirements
- PR process

---

## Timeline & Milestones

### Week 1-2: Foundation
- ✅ Create directory structure
- ✅ Define core interfaces
- ✅ Set up DI container
- ✅ Configure build system
- ✅ Set up CI/CD

### Week 3-4: Core Refactoring
- ✅ Refactor PSL layer
- ✅ Implement repository pattern
- ✅ Create service layer
- ✅ Update CLI commands

### Week 5-6: Query Engine
- ✅ Refactor query compiler
- ✅ Implement new query builder
- ✅ Add middleware system
- ✅ Improve SQL generation

### Week 7-8: Generator & Runtime
- ✅ Refactor code generator
- ✅ Implement plugin system
- ✅ Update runtime client
- ✅ Add advanced features

### Week 9-10: Testing & Documentation
- ✅ Add comprehensive tests (unit, integration, E2E)
- ✅ Set up benchmarks
- ✅ Write documentation
- ✅ Create examples

### Week 11-12: Polish & Release
- ✅ Performance optimization
- ✅ Bug fixes
- ✅ Release v2.0.0-alpha
- ✅ Gather feedback

---

## Success Criteria

### Technical Metrics
- ✅ Test coverage > 80%
- ✅ Zero circular dependencies
- ✅ All layers follow dependency rules
- ✅ Performance within 10% of v1.0
- ✅ Memory usage reduced by 20%

### Quality Metrics
- ✅ All linter checks pass
- ✅ No race conditions detected
- ✅ Documentation coverage 100%
- ✅ All examples work correctly

### User Experience
- ✅ Backward compatible API
- ✅ Clear error messages
- ✅ Plugin system works
- ✅ CLI is intuitive

---
## Conclusion

This restructuring will transform prisma-go into a production-ready, enterprise-grade ORM with:

1. **Clean Architecture** - Testable, maintainable, extensible
2. **Better Performance** - Optimized queries, connection pooling
3. **Enhanced Developer Experience** - Plugins, middleware, clear APIs
4. **Production Ready** - Comprehensive testing, logging, monitoring

The phased approach ensures minimal disruption while delivering incremental value.

**Next Steps:**
1. Review and approve this plan
2. Create GitHub issues for each phase
3. Set up project board for tracking
4. Begin implementation in Week 1

---

**Document Version:** 1.0  
**Last Updated:** December 2025  
**Author:** Architecture Team  
**Status:** Ready for Implementation