// Package template implements template-based code generation.
package template

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"

	"github.com/satishbabariya/prisma-go/v3/internal/core/generator/ir"
)

// Engine renders templates using Go's text/template system.
type Engine struct {
	templates *template.Template
}

// NewEngine creates a new template engine with the given templates.
func NewEngine() *Engine {
	return &Engine{
		templates: template.New("codegen").Funcs(TemplateFuncs()),
	}
}

// LoadTemplates loads templates from the given directory.
func (e *Engine) LoadTemplates(templatesDir string) error {
	_, err := e.templates.ParseGlob(templatesDir + "/*.tmpl")
	return err
}

// AddTemplate adds a single template to the engine.
func (e *Engine) AddTemplate(name, content string) error {
	_, err := e.templates.New(name).Parse(content)
	return err
}

// Render renders a template with the given data.
func (e *Engine) Render(templateName string, data interface{}) ([]byte, error) {
	tmpl := e.templates.Lookup(templateName)
	if tmpl == nil {
		return nil, fmt.Errorf("template not found: %s", templateName)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return nil, fmt.Errorf("failed to execute template %s: %w", templateName, err)
	}

	return buf.Bytes(), nil
}

// RenderModels renders model definitions.
func (e *Engine) RenderModels(ir *ir.IR) ([]byte, error) {
	content := e.generateModelsCode(ir)
	return []byte(content), nil
}

// RenderClient renders the client code.
func (e *Engine) RenderClient(ir *ir.IR) ([]byte, error) {
	content := e.generateClientCode(ir)
	return []byte(content), nil
}

// RenderQueries renders query method definitions.
func (e *Engine) RenderQueries(ir *ir.IR) ([]byte, error) {
	content := e.generateQueriesCode(ir)
	return []byte(content), nil
}

// RenderAll renders all code files.
func (e *Engine) RenderAll(ir *ir.IR) (map[string][]byte, error) {
	files := make(map[string][]byte)

	// Render models
	modelsCode, err := e.RenderModels(ir)
	if err != nil {
		return nil, fmt.Errorf("failed to render models: %w", err)
	}
	files["models.go"] = modelsCode

	// Render client
	clientCode, err := e.RenderClient(ir)
	if err != nil {
		return nil, fmt.Errorf("failed to render client: %w", err)
	}
	files["client.go"] = clientCode

	// Render queries
	queriesCode, err := e.RenderQueries(ir)
	if err != nil {
		return nil, fmt.Errorf("failed to render queries: %w", err)
	}
	files["queries.go"] = queriesCode

	return files, nil
}

// TemplateFuncs returns the default template functions.
func TemplateFuncs() template.FuncMap {
	return template.FuncMap{
		"toUpper":    strings.ToUpper,
		"toLower":    strings.ToLower,
		"goType":     goType,
		"isOptional": isOptional,
		"hasDefault": hasDefault,
	}
}

// Helper functions for templates
func goType(fieldType string) string {
	// Convert Prisma types to Go types
	switch fieldType {
	case "String":
		return "string"
	case "Int":
		return "int"
	case "BigInt":
		return "int64"
	case "Float":
		return "float64"
	case "Decimal":
		return "float64"
	case "Boolean":
		return "bool"
	case "DateTime":
		return "time.Time"
	case "Json":
		return "interface{}"
	case "Bytes":
		return "[]byte"
	default:
		return "interface{}"
	}
}

func isOptional(field interface{}) bool {
	// Check if field is optional based on IR structure
	return false // placeholder
}

func hasDefault(field interface{}) bool {
	// Check if field has default value
	return false // placeholder
}

func (e *Engine) generateModelsCode(ir *ir.IR) string {
	var buf strings.Builder

	buf.WriteString("// Code generated by prisma-go. DO NOT EDIT.\n\n")
	buf.WriteString("package models\n\n")
	buf.WriteString("import (\n")
	buf.WriteString("\t\"time\"\n")
	buf.WriteString(")\n\n")

	// Generate models
	for _, model := range ir.Models {
		buf.WriteString(fmt.Sprintf("// %s represents %s model.\n", model.Name, model.Name))
		buf.WriteString(fmt.Sprintf("type %s struct {\n", model.Name))

		for _, field := range model.Fields {
			goTypeStr := field.Type.GoType
			if goTypeStr == "" {
				goTypeStr = goType(field.Type.PrismaType)
			}
			tag := fmt.Sprintf("`json:\"%s\"`", field.Name)
			if field.IsOptional {
				tag = fmt.Sprintf("`json:\"%s,omitempty\"`", field.Name)
			}
			buf.WriteString(fmt.Sprintf("\t%s %s %s\n", field.Name, goTypeStr, tag))
		}

		buf.WriteString("}\n\n")
	}

	// Generate enums
	for _, enum := range ir.Enums {
		buf.WriteString(fmt.Sprintf("// %s represents %s enum.\n", enum.Name, enum.Name))
		buf.WriteString(fmt.Sprintf("type %s string\n\n", enum.Name))
		buf.WriteString("const (\n")

		for _, value := range enum.Values {
			buf.WriteString(fmt.Sprintf("\t%s%s %s = \"%s\"\n", enum.Name, value, enum.Name, value))
		}

		buf.WriteString(")\n\n")
	}

	return buf.String()
}

func (e *Engine) generateClientCode(ir *ir.IR) string {
	var buf strings.Builder

	buf.WriteString("// Code generated by prisma-go. DO NOT EDIT.\n\n")
	buf.WriteString("package client\n\n")
	buf.WriteString("import (\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"database/sql\"\n")
	buf.WriteString("\t\"fmt\"\n\n")
	buf.WriteString("\t\"github.com/satishbabariya/prisma-go/v3/runtime\"\n")
	buf.WriteString(")\n\n")

	// Main Client
	buf.WriteString("// Client is the main Prisma client.\n")
	buf.WriteString("type Client struct {\n")
	buf.WriteString("\tdb     *sql.DB\n")
	buf.WriteString("\tengine *runtime.QueryEngine\n")
	buf.WriteString("}\n\n")

	buf.WriteString("// NewClient creates a new Prisma client.\n")
	buf.WriteString("func NewClient(db *sql.DB) *Client {\n")
	buf.WriteString("\treturn &Client{\n")
	buf.WriteString("\t\tdb:     db,\n")
	buf.WriteString("\t\tengine: runtime.NewQueryEngine(db),\n")
	buf.WriteString("\t}\n")
	buf.WriteString("}\n\n")

	buf.WriteString("// Close closes the database connection.\n")
	buf.WriteString("func (c *Client) Close() error {\n")
	buf.WriteString("\tif c.db != nil {\n")
	buf.WriteString("\t\treturn c.db.Close()\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn nil\n")
	buf.WriteString("}\n\n")

	buf.WriteString("// WithContext returns a client with the given context.\n")
	buf.WriteString("func (c *Client) WithContext(ctx context.Context) *ClientCtx {\n")
	buf.WriteString("\treturn &ClientCtx{\n")
	buf.WriteString("\t\tclient: c,\n")
	buf.WriteString("\t\tctx:    ctx,\n")
	buf.WriteString("\t}\n")
	buf.WriteString("}\n\n")

	// ClientCtx
	buf.WriteString("// ClientCtx provides query methods with context.\n")
	buf.WriteString("type ClientCtx struct {\n")
	buf.WriteString("\tclient *Client\n")
	buf.WriteString("\tctx    context.Context\n")
	buf.WriteString("}\n\n")

	// Generate model query types
	for _, model := range ir.Models {
		buf.WriteString(fmt.Sprintf("// %s provides access to %s model queries.\n", model.Name, model.Name))
		buf.WriteString(fmt.Sprintf("func (c *ClientCtx) %s() *%sQuery {\n", model.Name, model.Name))
		buf.WriteString(fmt.Sprintf("\treturn &%sQuery{\n", model.Name))
		buf.WriteString("\t\tclient: c.client,\n")
		buf.WriteString("\t\tctx:    c.ctx,\n")
		buf.WriteString("\t}\n")
		buf.WriteString("}\n\n")

		buf.WriteString(fmt.Sprintf("// %sQuery provides query methods for %s model.\n", model.Name, model.Name))
		buf.WriteString(fmt.Sprintf("type %sQuery struct {\n", model.Name))
		buf.WriteString("\tclient *Client\n")
		buf.WriteString("\tctx    context.Context\n")
		buf.WriteString("\twhere  map[string]interface{}\n")
		buf.WriteString("}\n\n")

		// Add basic query methods
		methods := []string{"FindMany", "FindFirst", "FindUnique", "Create", "Update", "Delete"}
		for _, method := range methods {
			buf.WriteString(fmt.Sprintf("// %s %s %s records.\n", method, method, model.Name))
			buf.WriteString(fmt.Sprintf("func (q *%sQuery) %s(", model.Name, method))

			if method == "Create" || method == "Update" {
				buf.WriteString("data map[string]interface{}")
			}

			buf.WriteString(fmt.Sprintf(") (*%s, error) {\n", model.Name))
			buf.WriteString(fmt.Sprintf("\t// This will be implemented with proper query building\n"))
			buf.WriteString(fmt.Sprintf("\treturn nil, fmt.Errorf(\"%s not yet implemented for %s\")\n", method, model.Name))
			buf.WriteString("}\n\n")
		}

		buf.WriteString("// Where adds a where clause to the query.\n")
		buf.WriteString(fmt.Sprintf("func (q *%sQuery) Where(conditions map[string]interface{}) *%sQuery {\n", model.Name, model.Name))
		buf.WriteString("\tq.where = conditions\n")
		buf.WriteString("\treturn q\n")
		buf.WriteString("}\n\n")
	}

	return buf.String()
}

func (e *Engine) generateQueriesCode(ir *ir.IR) string {
	var buf strings.Builder

	buf.WriteString("// Code generated by prisma-go. DO NOT EDIT.\n\n")
	buf.WriteString("package client\n\n")
	buf.WriteString("import (\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString(")\n\n")

	buf.WriteString("// This file contains additional query methods and helpers.\n\n")

	// Generate parameter types for each model
	for _, model := range ir.Models {
		buf.WriteString(fmt.Sprintf("// FindMany%sParams defines parameters for FindMany queries.\n", model.Name))
		buf.WriteString(fmt.Sprintf("type FindMany%sParams struct {\n", model.Name))
		buf.WriteString("\tWhere     map[string]interface{} `json:\"where,omitempty\"`\n")
		buf.WriteString("\tOrderBy   []map[string]interface{} `json:\"orderBy,omitempty\"`\n")
		buf.WriteString("\tSkip      *int                     `json:\"skip,omitempty\"`\n")
		buf.WriteString("\tTake      *int                     `json:\"take,omitempty\"`\n")
		buf.WriteString("\tCursor    map[string]interface{}   `json:\"cursor,omitempty\"`\n")
		buf.WriteString("}\n\n")

		buf.WriteString(fmt.Sprintf("// %sWhere provides type-safe where conditions.\n", model.Name))
		buf.WriteString(fmt.Sprintf("type %sWhere struct {\n", model.Name))
		buf.WriteString("\t// This will be expanded with specific field conditions\n")
		buf.WriteString(fmt.Sprintf("\tAnd []%sWhere `json:\"_and,omitempty\"`\n", model.Name))
		buf.WriteString(fmt.Sprintf("\tOr  []%sWhere `json:\"_or,omitempty\"`\n", model.Name))
		buf.WriteString(fmt.Sprintf("\tNot *%sWhere `json:\"_not,omitempty\"`\n", model.Name))
		buf.WriteString("}\n\n")

		buf.WriteString(fmt.Sprintf("// %sOrderBy defines ordering for %s queries.\n", model.Name, model.Name))
		buf.WriteString(fmt.Sprintf("type %sOrderBy struct {\n", model.Name))
		buf.WriteString("\tField     string `json:\"field\"`\n")
		buf.WriteString("\tDirection string `json:\"direction\"` // \"asc\" or \"desc\"\n")
		buf.WriteString("}\n\n")
	}

	return buf.String()
}

// addBuiltinTemplates adds basic templates when file loading fails.
func (e *Engine) addBuiltinTemplates() {
	// Templates are now embedded in the generate methods above
}
