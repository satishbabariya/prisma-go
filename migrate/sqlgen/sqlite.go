// Package sqlgen generates migration SQL for SQLite.
package sqlgen

import (
	"fmt"
	"strings"

	"github.com/satishbabariya/prisma-go/migrate/diff"
	"github.com/satishbabariya/prisma-go/migrate/introspect"
)

// SQLiteMigrationGenerator generates SQLite migration SQL
type SQLiteMigrationGenerator struct{}

// NewSQLiteMigrationGenerator creates a new SQLite migration generator
func NewSQLiteMigrationGenerator() *SQLiteMigrationGenerator {
	return &SQLiteMigrationGenerator{}
}

// GenerateMigrationSQL generates SQL for a diff result
func (g *SQLiteMigrationGenerator) GenerateMigrationSQL(diffResult *diff.DiffResult, dbSchema *introspect.DatabaseSchema) (string, error) {
	var sql strings.Builder

	sql.WriteString("-- Migration SQL generated by Prisma-Go for SQLite\n")
	sql.WriteString("-- WARNING: Review this SQL before running it!\n")
	sql.WriteString("-- Note: SQLite has limited ALTER TABLE support\n\n")

	// 1. Create tables
	for _, change := range diffResult.TablesToCreate {
		// Find table in target schema (dbSchema is the target schema)
		var targetTable *introspect.Table
		for i := range dbSchema.Tables {
			if dbSchema.Tables[i].Name == change.Name {
				targetTable = &dbSchema.Tables[i]
				break
			}
		}
		if targetTable == nil {
			return "", fmt.Errorf("table %s not found in target schema", change.Name)
		}

		createSQL, err := g.generateCreateTableFromTable(targetTable)
		if err != nil {
			return "", fmt.Errorf("failed to generate CREATE TABLE for %s: %w", change.Name, err)
		}
		sql.WriteString(createSQL)
		sql.WriteString("\n\n")
	}

	// 2. Alter tables (limited in SQLite)
	for _, change := range diffResult.TablesToAlter {
		alterSQL := g.generateAlterTable(change, dbSchema)
		if alterSQL != "" {
			sql.WriteString(alterSQL)
			sql.WriteString("\n\n")
		}
	}

	// 3. Drop tables
	for _, change := range diffResult.TablesToDrop {
		sql.WriteString(fmt.Sprintf("-- WARNING: Dropping table '%s' will delete all data!\n", change.Name))
		sql.WriteString(fmt.Sprintf("DROP TABLE IF EXISTS \"%s\";\n\n", change.Name))
	}

	return sql.String(), nil
}

// GenerateRollbackSQL generates rollback SQL for a diff result
func (g *SQLiteMigrationGenerator) GenerateRollbackSQL(diffResult *diff.DiffResult, dbSchema *introspect.DatabaseSchema) (string, error) {
	return g.GenerateRollbackSQLWithPreviousSchema(diffResult, dbSchema, nil)
}

// GenerateRollbackSQLWithPreviousSchema generates rollback SQL using stored schema state
func (g *SQLiteMigrationGenerator) GenerateRollbackSQLWithPreviousSchema(diffResult *diff.DiffResult, dbSchema *introspect.DatabaseSchema, previousSchema *introspect.DatabaseSchema) (string, error) {
	var sql strings.Builder

	sql.WriteString("-- Rollback SQL generated by Prisma-Go for SQLite\n")
	sql.WriteString("-- WARNING: Review this SQL before running it!\n")
	sql.WriteString("-- Note: SQLite has limited ALTER TABLE support\n\n")

	// Rollback in reverse order: Drop, Alter, Create

	// 1. Rollback table drops
	for _, change := range diffResult.TablesToDrop {
		if previousSchema != nil {
			// Find table in previous schema
			var previousTable *introspect.Table
			for i := range previousSchema.Tables {
				if previousSchema.Tables[i].Name == change.Name {
					previousTable = &previousSchema.Tables[i]
					break
				}
			}
			if previousTable != nil {
				// Generate CREATE TABLE from stored schema
				createSQL, err := g.generateCreateTableFromTable(previousTable)
				if err != nil {
					return "", fmt.Errorf("failed to generate CREATE TABLE for %s: %w", change.Name, err)
				}
				sql.WriteString(createSQL)
				sql.WriteString("\n\n")
				continue
			}
		}
		// Fallback: generate placeholder if schema not available
		sql.WriteString(fmt.Sprintf("-- TODO: Recreate dropped table '%s' (schema history not available)\n", change.Name))
		sql.WriteString(fmt.Sprintf("-- CREATE TABLE \"%s\" (...);\n\n", change.Name))
	}

	// 2. Rollback table alters
	for _, change := range diffResult.TablesToAlter {
		rollbackSQL := g.generateRollbackAlterTable(change, dbSchema)
		if rollbackSQL != "" {
			sql.WriteString(rollbackSQL)
			sql.WriteString("\n\n")
		}
	}

	// 3. Rollback table creates
	for _, change := range diffResult.TablesToCreate {
		sql.WriteString(fmt.Sprintf("DROP TABLE IF EXISTS \"%s\";\n\n", change.Name))
	}

	return sql.String(), nil
}

// generateRollbackAlterTable generates rollback SQL for ALTER TABLE changes
func (g *SQLiteMigrationGenerator) generateRollbackAlterTable(change diff.TableChange, dbSchema *introspect.DatabaseSchema) string {
	if len(change.Changes) == 0 {
		return ""
	}

	var sql strings.Builder

	// Process changes in reverse order
	for i := len(change.Changes) - 1; i >= 0; i-- {
		ch := change.Changes[i]
		switch ch.Type {
		case "AddColumn":
			// SQLite doesn't support DROP COLUMN, would need table recreation
			sql.WriteString(fmt.Sprintf("-- SQLite doesn't support DROP COLUMN - table recreation required\n"))
			sql.WriteString(fmt.Sprintf("-- TODO: Drop column %s.%s\n", change.Name, ch.Column))

		case "DropColumn":
			sql.WriteString(fmt.Sprintf("-- TODO: Add back dropped column %s.%s\n",
				change.Name, ch.Column))

		case "AlterColumn":
			sql.WriteString(fmt.Sprintf("-- SQLite doesn't support ALTER COLUMN - table recreation required\n"))
			if ch.ColumnMetadata != nil && ch.ColumnMetadata.OldType != "" {
				var pk *introspect.PrimaryKey
				if dbSchema != nil {
					for _, table := range dbSchema.Tables {
						if table.Name == change.Name {
							pk = table.PrimaryKey
							break
						}
					}
				}
				colDef := g.generateColumnDefinitionFromMetadata(ch.ColumnMetadata, ch.Column, pk)
				sql.WriteString(fmt.Sprintf("-- TODO: Restore column %s.%s to %s (requires table recreation)\n",
					change.Name, ch.Column, colDef))
			} else {
				sql.WriteString(fmt.Sprintf("-- TODO: Restore column %s.%s (metadata missing)\n", change.Name, ch.Column))
			}

		case "CreateIndex":
			sql.WriteString(fmt.Sprintf("DROP INDEX IF EXISTS \"%s\";\n", ch.Index))

		case "DropIndex":
			sql.WriteString(fmt.Sprintf("-- TODO: Recreate dropped index %s (requires schema history)\n", ch.Index))
			sql.WriteString(fmt.Sprintf("-- CREATE INDEX \"%s\" ON \"%s\" (...);\n", ch.Index, change.Name))

		case "RenameIndex":
			// SQLite doesn't support index renames
			sql.WriteString(fmt.Sprintf("-- SQLite doesn't support index renames\n"))
			sql.WriteString(fmt.Sprintf("-- TODO: Drop %s and recreate as %s\n", ch.NewName, ch.OldName))

		case "CreateForeignKey":
			// SQLite foreign keys are managed through table recreation
			sql.WriteString(fmt.Sprintf("-- SQLite foreign key %s would be dropped during table recreation\n", ch.Index))

		case "DropForeignKey":
			sql.WriteString(fmt.Sprintf("-- TODO: Recreate dropped foreign key %s (requires schema history)\n", ch.Index))
			sql.WriteString(fmt.Sprintf("-- FOREIGN KEY (...) REFERENCES ...;\n"))

		case "RenameForeignKey":
			sql.WriteString(fmt.Sprintf("-- SQLite doesn't support FK renames\n"))
			sql.WriteString(fmt.Sprintf("-- TODO: Drop %s and recreate as %s\n", ch.NewName, ch.OldName))
		}
	}

	return sql.String()
}

// generateCreateTableFromTable generates CREATE TABLE SQL for SQLite from a table definition
func (g *SQLiteMigrationGenerator) generateCreateTableFromTable(table *introspect.Table) (string, error) {
	var sql strings.Builder
	sql.WriteString(fmt.Sprintf("CREATE TABLE \"%s\" (\n", table.Name))

	// Columns
	columnDefs := []string{}
	for _, col := range table.Columns {
		colDef := g.generateColumnDefinition(col, table.PrimaryKey)
		columnDefs = append(columnDefs, "  "+colDef)
	}

	// Primary key (if composite)
	if table.PrimaryKey != nil && len(table.PrimaryKey.Columns) > 1 {
		pkCols := make([]string, len(table.PrimaryKey.Columns))
		for i, col := range table.PrimaryKey.Columns {
			pkCols[i] = fmt.Sprintf("\"%s\"", col)
		}
		columnDefs = append(columnDefs, fmt.Sprintf("  PRIMARY KEY (%s)", strings.Join(pkCols, ", ")))
	}

	// Foreign keys (inline)
	for _, fk := range table.ForeignKeys {
		fkDef := g.generateForeignKeyDefinition(fk)
		columnDefs = append(columnDefs, "  "+fkDef)
	}

	sql.WriteString(strings.Join(columnDefs, ",\n"))
	sql.WriteString("\n);")

	// Indexes (separate statements)
	for _, idx := range table.Indexes {
		sql.WriteString("\n")
		sql.WriteString(g.generateCreateIndex(table.Name, idx))
	}

	return sql.String(), nil
}

// generateColumnDefinition generates a column definition for SQLite
func (g *SQLiteMigrationGenerator) generateColumnDefinition(col introspect.Column, pk *introspect.PrimaryKey) string {
	// Map generic types to SQLite types
	sqliteType := g.mapToSQLiteType(col.Type)
	def := fmt.Sprintf("\"%s\" %s", col.Name, sqliteType)

	// Check if this column is a single-column primary key
	isSinglePK := false
	if pk != nil && len(pk.Columns) == 1 && pk.Columns[0] == col.Name {
		isSinglePK = true
	}

	if isSinglePK {
		def += " PRIMARY KEY"
		if col.AutoIncrement {
			def += " AUTOINCREMENT"
		}
	}

	if !col.Nullable && !isSinglePK {
		def += " NOT NULL"
	}

	if col.DefaultValue != nil && *col.DefaultValue != "" && !col.AutoIncrement {
		def += fmt.Sprintf(" DEFAULT %s", *col.DefaultValue)
	}

	return def
}

// mapToSQLiteType maps generic types to SQLite types
func (g *SQLiteMigrationGenerator) mapToSQLiteType(genericType string) string {
	upperType := strings.ToUpper(genericType)

	switch {
	case strings.Contains(upperType, "INT"), strings.Contains(upperType, "SERIAL"):
		return "INTEGER"
	case strings.Contains(upperType, "BOOL"):
		return "INTEGER" // SQLite uses INTEGER for booleans
	case strings.Contains(upperType, "VARCHAR"), strings.Contains(upperType, "CHAR"), upperType == "TEXT", upperType == "UUID":
		return "TEXT"
	case strings.Contains(upperType, "DECIMAL"), strings.Contains(upperType, "NUMERIC"), strings.Contains(upperType, "FLOAT"), strings.Contains(upperType, "DOUBLE"), strings.Contains(upperType, "REAL"):
		return "REAL"
	case strings.Contains(upperType, "TIMESTAMP"), strings.Contains(upperType, "DATE"), strings.Contains(upperType, "TIME"):
		return "TEXT" // SQLite stores dates as TEXT
	case upperType == "JSON" || upperType == "JSONB":
		return "TEXT"
	case upperType == "BYTEA" || strings.Contains(upperType, "BLOB"):
		return "BLOB"
	default:
		// Default to TEXT for unknown types
		return "TEXT"
	}
}

// generateAlterTable generates ALTER TABLE SQL for SQLite
func (g *SQLiteMigrationGenerator) generateAlterTable(change diff.TableChange, dbSchema *introspect.DatabaseSchema) string {
	if len(change.Changes) == 0 {
		return ""
	}

	var sql strings.Builder

	// SQLite has very limited ALTER TABLE support
	// We can only:
	// - RENAME TABLE
	// - ADD COLUMN (with restrictions)
	// For other changes, we need to recreate the table

	addColumns := []diff.Change{}
	otherChanges := []diff.Change{}

	for _, ch := range change.Changes {
		if ch.Type == "AddColumn" {
			addColumns = append(addColumns, ch)
		} else if ch.Type == "RenameIndex" || ch.Type == "RenameForeignKey" {
			// SQLite doesn't support renames - treat as drop + create
			// Add comment explaining this
			otherChanges = append(otherChanges, ch)
		} else {
			otherChanges = append(otherChanges, ch)
		}
	}

	// Handle ADD COLUMN (supported)
	// Find the table in dbSchema to get primary key info
	var targetTable *introspect.Table
	for i := range dbSchema.Tables {
		if dbSchema.Tables[i].Name == change.Name {
			targetTable = &dbSchema.Tables[i]
			break
		}
	}

	for _, ch := range addColumns {
		sql.WriteString(fmt.Sprintf("-- Add column %s.%s\n", change.Name, ch.Column))
		if ch.ColumnMetadata != nil {
			var pk *introspect.PrimaryKey
			if targetTable != nil {
				pk = targetTable.PrimaryKey
			}
			colDef := g.generateColumnDefinitionFromMetadata(ch.ColumnMetadata, ch.Column, pk)
			sql.WriteString(fmt.Sprintf("ALTER TABLE \"%s\" ADD COLUMN \"%s\" %s;\n",
				change.Name, ch.Column, colDef))
		} else {
			// Fallback to TEXT if metadata is missing
			sql.WriteString(fmt.Sprintf("ALTER TABLE \"%s\" ADD COLUMN \"%s\" TEXT;\n",
				change.Name, ch.Column))
		}
	}

	// Handle other changes (require table recreation)
	if len(otherChanges) > 0 {
		sql.WriteString(fmt.Sprintf("\n-- WARNING: The following changes require table recreation in SQLite:\n"))
		for _, ch := range otherChanges {
			if ch.Type == "RenameIndex" {
				sql.WriteString(fmt.Sprintf("-- %s: %s (SQLite doesn't support index renames - drop and recreate)\n", ch.Type, ch.Description))
			} else if ch.Type == "RenameForeignKey" {
				sql.WriteString(fmt.Sprintf("-- %s: %s (SQLite doesn't support FK renames - drop and recreate)\n", ch.Type, ch.Description))
			} else {
				sql.WriteString(fmt.Sprintf("-- %s: %s\n", ch.Type, ch.Description))
			}
		}
		sql.WriteString(fmt.Sprintf("\n-- Table recreation pattern:\n"))
		sql.WriteString(fmt.Sprintf("-- 1. CREATE TABLE %s_new (...)\n", change.Name))
		sql.WriteString(fmt.Sprintf("-- 2. INSERT INTO %s_new SELECT ... FROM %s\n", change.Name, change.Name))
		sql.WriteString(fmt.Sprintf("-- 3. DROP TABLE %s\n", change.Name))
		sql.WriteString(fmt.Sprintf("-- 4. ALTER TABLE %s_new RENAME TO %s\n\n", change.Name, change.Name))
	}

	return sql.String()
}

// generateCreateIndex generates CREATE INDEX SQL for SQLite
func (g *SQLiteMigrationGenerator) generateCreateIndex(tableName string, idx introspect.Index) string {
	unique := ""
	if idx.IsUnique {
		unique = "UNIQUE "
	}

	cols := make([]string, len(idx.Columns))
	for i, col := range idx.Columns {
		cols[i] = fmt.Sprintf("\"%s\"", col)
	}

	return fmt.Sprintf("CREATE %sINDEX \"%s\" ON \"%s\" (%s);",
		unique, idx.Name, tableName, strings.Join(cols, ", "))
}

// generateForeignKeyDefinition generates FOREIGN KEY constraint for SQLite
func (g *SQLiteMigrationGenerator) generateForeignKeyDefinition(fk introspect.ForeignKey) string {
	cols := make([]string, len(fk.Columns))
	for i, col := range fk.Columns {
		cols[i] = fmt.Sprintf("\"%s\"", col)
	}

	refCols := make([]string, len(fk.ReferencedColumns))
	for i, col := range fk.ReferencedColumns {
		refCols[i] = fmt.Sprintf("\"%s\"", col)
	}

	sql := fmt.Sprintf("FOREIGN KEY (%s) REFERENCES \"%s\" (%s)",
		strings.Join(cols, ", "), fk.ReferencedTable, strings.Join(refCols, ", "))

	if fk.OnUpdate != "" && fk.OnUpdate != "NO ACTION" {
		sql += fmt.Sprintf(" ON UPDATE %s", fk.OnUpdate)
	}

	if fk.OnDelete != "" && fk.OnDelete != "NO ACTION" {
		sql += fmt.Sprintf(" ON DELETE %s", fk.OnDelete)
	}

	return sql
}

// generateColumnDefinitionFromMetadata generates a column definition from ColumnMetadata for SQLite
func (g *SQLiteMigrationGenerator) generateColumnDefinitionFromMetadata(meta *diff.ColumnMetadata, columnName string, pk *introspect.PrimaryKey) string {
	// Map generic types to SQLite types
	sqliteType := g.mapToSQLiteType(meta.Type)
	def := sqliteType

	// Check if this column is a single-column primary key
	isSinglePK := false
	if pk != nil && len(pk.Columns) == 1 && pk.Columns[0] == columnName {
		isSinglePK = true
	}

	if isSinglePK {
		def += " PRIMARY KEY"
		if meta.AutoIncrement {
			def += " AUTOINCREMENT"
		}
	}

	if !meta.Nullable && !isSinglePK {
		def += " NOT NULL"
	}

	if meta.DefaultValue != nil && *meta.DefaultValue != "" && !meta.AutoIncrement {
		def += fmt.Sprintf(" DEFAULT %s", *meta.DefaultValue)
	}

	return def
}
