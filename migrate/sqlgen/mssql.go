// Package sqlgen generates migration SQL for SQL Server.
package sqlgen

import (
	"fmt"
	"strings"

	"github.com/satishbabariya/prisma-go/migrate/diff"
	"github.com/satishbabariya/prisma-go/migrate/introspect"
)

// SQLServerMigrationGenerator generates SQL Server migration SQL
type SQLServerMigrationGenerator struct{}

// NewSQLServerMigrationGenerator creates a new SQL Server migration generator
func NewSQLServerMigrationGenerator() *SQLServerMigrationGenerator {
	return &SQLServerMigrationGenerator{}
}

// GenerateMigrationSQL generates SQL for a diff result
func (g *SQLServerMigrationGenerator) GenerateMigrationSQL(diffResult *diff.DiffResult, dbSchema *introspect.DatabaseSchema) (string, error) {
	var sql strings.Builder

	sql.WriteString("-- Migration SQL generated by Prisma-Go for SQL Server\n")
	sql.WriteString("-- WARNING: Review this SQL before running it!\n\n")

	// 1. Create tables
	for _, change := range diffResult.TablesToCreate {
		var targetTable *introspect.Table
		for i := range dbSchema.Tables {
			if dbSchema.Tables[i].Name == change.Name {
				targetTable = &dbSchema.Tables[i]
				break
			}
		}
		if targetTable == nil {
			return "", fmt.Errorf("table %s not found in target schema", change.Name)
		}

		createSQL, err := g.generateCreateTableFromTable(targetTable)
		if err != nil {
			return "", fmt.Errorf("failed to generate CREATE TABLE for %s: %w", change.Name, err)
		}
		sql.WriteString(createSQL)
		sql.WriteString("\n\n")
	}

	// 2. Alter tables
	for _, change := range diffResult.TablesToAlter {
		alterSQL := g.generateAlterTable(change, dbSchema)
		if alterSQL != "" {
			sql.WriteString(alterSQL)
			sql.WriteString("\n\n")
		}
	}

	// 3. Drop tables
	for _, change := range diffResult.TablesToDrop {
		sql.WriteString(fmt.Sprintf("-- WARNING: Dropping table '%s' will delete all data!\n", change.Name))
		sql.WriteString(fmt.Sprintf("IF OBJECT_ID('[%s]', 'U') IS NOT NULL DROP TABLE [%s];\n\n", change.Name, change.Name))
	}

	return sql.String(), nil
}

// generateCreateTableFromTable generates CREATE TABLE SQL from a Table struct
func (g *SQLServerMigrationGenerator) generateCreateTableFromTable(table *introspect.Table) (string, error) {
	var sql strings.Builder

	sql.WriteString(fmt.Sprintf("CREATE TABLE [%s] (\n", table.Name))

	var columnDefs []string
	for _, col := range table.Columns {
		def := g.generateColumnDefinition(col)
		columnDefs = append(columnDefs, "  "+def)
	}

	// Add primary key constraint if exists
	if table.PrimaryKey != nil && len(table.PrimaryKey.Columns) > 0 {
		pkCols := make([]string, len(table.PrimaryKey.Columns))
		for i, col := range table.PrimaryKey.Columns {
			pkCols[i] = fmt.Sprintf("[%s]", col)
		}
		columnDefs = append(columnDefs, fmt.Sprintf("  CONSTRAINT [%s] PRIMARY KEY (%s)", table.PrimaryKey.Name, strings.Join(pkCols, ", ")))
	}

	sql.WriteString(strings.Join(columnDefs, ",\n"))
	sql.WriteString("\n);\n")

	// Add indexes
	for _, idx := range table.Indexes {
		if idx.IsUnique {
			sql.WriteString(fmt.Sprintf("CREATE UNIQUE INDEX [%s] ON [%s] (%s);\n", idx.Name, table.Name, g.quoteColumns(idx.Columns)))
		} else {
			sql.WriteString(fmt.Sprintf("CREATE INDEX [%s] ON [%s] (%s);\n", idx.Name, table.Name, g.quoteColumns(idx.Columns)))
		}
	}

	// Add foreign keys
	for _, fk := range table.ForeignKeys {
		sql.WriteString(fmt.Sprintf("ALTER TABLE [%s] ADD CONSTRAINT [%s] FOREIGN KEY (%s) REFERENCES [%s] (%s);\n",
			table.Name, fk.Name, g.quoteColumns(fk.Columns), fk.ReferencedTable, g.quoteColumns(fk.ReferencedColumns)))
	}

	return sql.String(), nil
}

// generateColumnDefinition generates a column definition for SQL Server
func (g *SQLServerMigrationGenerator) generateColumnDefinition(col introspect.Column) string {
	var def strings.Builder

	def.WriteString(fmt.Sprintf("[%s] %s", col.Name, g.mapPrismaTypeToSQLServer(col.Type)))

	if !col.Nullable {
		def.WriteString(" NOT NULL")
	}

	if col.DefaultValue != nil && *col.DefaultValue != "" {
		def.WriteString(fmt.Sprintf(" DEFAULT %s", *col.DefaultValue))
	}

	if col.AutoIncrement {
		def.WriteString(" IDENTITY(1,1)")
	}

	return def.String()
}

// mapPrismaTypeToSQLServer maps Prisma types to SQL Server types
func (g *SQLServerMigrationGenerator) mapPrismaTypeToSQLServer(prismaType string) string {
	switch prismaType {
	case "Int":
		return "INT"
	case "BigInt":
		return "BIGINT"
	case "Boolean":
		return "BIT"
	case "String":
		return "NVARCHAR(MAX)"
	case "DateTime":
		return "DATETIME2"
	case "Float":
		return "FLOAT"
	case "Decimal":
		return "DECIMAL(18,2)"
	case "Json":
		return "NVARCHAR(MAX)" // SQL Server 2016+ has JSON support
	case "Bytes":
		return "VARBINARY(MAX)"
	default:
		return "NVARCHAR(MAX)"
	}
}

// quoteColumns quotes column names for SQL Server
func (g *SQLServerMigrationGenerator) quoteColumns(cols []string) string {
	quoted := make([]string, len(cols))
	for i, col := range cols {
		quoted[i] = fmt.Sprintf("[%s]", col)
	}
	return strings.Join(quoted, ", ")
}

// generateAlterTable generates ALTER TABLE SQL
func (g *SQLServerMigrationGenerator) generateAlterTable(change diff.TableChange, dbSchema *introspect.DatabaseSchema) string {
	if len(change.Changes) == 0 {
		return ""
	}

	var sql strings.Builder

	sql.WriteString(fmt.Sprintf("-- Alter table [%s]\n", change.Name))

	for _, ch := range change.Changes {
		switch ch.Type {
		case diff.ChangeTypeAddColumn:
			sql.WriteString(fmt.Sprintf("-- Add column [%s].[%s]\n", change.Name, ch.Column))
			if ch.ColumnMetadata != nil {
				colDef := g.generateColumnDefinitionFromMetadata(ch.ColumnMetadata, ch.Column)
				sql.WriteString(fmt.Sprintf("ALTER TABLE [%s] ADD [%s] %s;\n",
					change.Name, ch.Column, colDef))
			} else {
				sql.WriteString(fmt.Sprintf("ALTER TABLE [%s] ADD [%s] NVARCHAR(MAX);\n",
					change.Name, ch.Column))
			}

		case diff.ChangeTypeDropColumn:
			sql.WriteString(fmt.Sprintf("-- WARNING: Dropping column [%s].[%s] will delete all data!\n", change.Name, ch.Column))
			sql.WriteString(fmt.Sprintf("ALTER TABLE [%s] DROP COLUMN [%s];\n",
				change.Name, ch.Column))

		case diff.ChangeTypeAlterColumn:
			sql.WriteString(fmt.Sprintf("-- Alter column [%s].[%s]\n", change.Name, ch.Column))
			if ch.ColumnMetadata != nil {
				// SQL Server requires separate ALTER COLUMN statements
				if ch.ColumnMetadata.OldType != "" && ch.ColumnMetadata.OldType != ch.ColumnMetadata.Type {
					sql.WriteString(fmt.Sprintf("ALTER TABLE [%s] ALTER COLUMN [%s] %s;\n",
						change.Name, ch.Column, g.mapPrismaTypeToSQLServer(ch.ColumnMetadata.Type)))
				}
				if ch.ColumnMetadata.OldNullable != nil && *ch.ColumnMetadata.OldNullable != ch.ColumnMetadata.Nullable {
					colType := g.mapPrismaTypeToSQLServer(ch.ColumnMetadata.Type)
					if ch.ColumnMetadata.Nullable {
						sql.WriteString(fmt.Sprintf("ALTER TABLE [%s] ALTER COLUMN [%s] %s NULL;\n",
							change.Name, ch.Column, colType))
					} else {
						sql.WriteString(fmt.Sprintf("ALTER TABLE [%s] ALTER COLUMN [%s] %s NOT NULL;\n",
							change.Name, ch.Column, colType))
					}
				}
			}

		case diff.ChangeTypeCreateIndex:
			sql.WriteString(fmt.Sprintf("CREATE INDEX [%s] ON [%s] ([%s]);\n",
				ch.Index, change.Name, ch.Column))

		case diff.ChangeTypeDropIndex:
			sql.WriteString(fmt.Sprintf("DROP INDEX [%s] ON [%s];\n",
				ch.Index, change.Name))
		}
	}

	return sql.String()
}

// generateColumnDefinitionFromMetadata generates a column definition from metadata
func (g *SQLServerMigrationGenerator) generateColumnDefinitionFromMetadata(meta *diff.ColumnMetadata, colName string) string {
	var def strings.Builder

	def.WriteString(fmt.Sprintf("[%s] %s", colName, g.mapPrismaTypeToSQLServer(meta.Type)))

	if !meta.Nullable {
		def.WriteString(" NOT NULL")
	}

	if meta.DefaultValue != nil && *meta.DefaultValue != "" {
		def.WriteString(fmt.Sprintf(" DEFAULT %s", *meta.DefaultValue))
	}

	if meta.AutoIncrement {
		def.WriteString(" IDENTITY(1,1)")
	}

	return def.String()
}

// GenerateRollbackSQL generates rollback SQL for a diff result
func (g *SQLServerMigrationGenerator) GenerateRollbackSQL(diffResult *diff.DiffResult, dbSchema *introspect.DatabaseSchema) (string, error) {
	return g.GenerateRollbackSQLWithPreviousSchema(diffResult, dbSchema, nil)
}

// GenerateRollbackSQLWithPreviousSchema generates rollback SQL using stored schema state
func (g *SQLServerMigrationGenerator) GenerateRollbackSQLWithPreviousSchema(diffResult *diff.DiffResult, dbSchema *introspect.DatabaseSchema, previousSchema *introspect.DatabaseSchema) (string, error) {
	var sql strings.Builder

	sql.WriteString("-- Rollback SQL generated by Prisma-Go for SQL Server\n")
	sql.WriteString("-- WARNING: Review this SQL before running it!\n\n")

	// Rollback in reverse order: Drop, Alter, Create

	// 1. Rollback table drops (recreate dropped tables)
	for _, change := range diffResult.TablesToDrop {
		if previousSchema != nil {
			// Find table in previous schema
			var previousTable *introspect.Table
			for i := range previousSchema.Tables {
				if previousSchema.Tables[i].Name == change.Name {
					previousTable = &previousSchema.Tables[i]
					break
				}
			}
			if previousTable != nil {
				// Generate CREATE TABLE from stored schema
				createSQL, err := g.generateCreateTableFromTable(previousTable)
				if err != nil {
					return "", fmt.Errorf("failed to generate CREATE TABLE for %s: %w", change.Name, err)
				}
				sql.WriteString(createSQL)
				sql.WriteString("\n\n")
				continue
			}
		}
		// Fallback: generate placeholder if schema not available
		sql.WriteString(fmt.Sprintf("-- TODO: Recreate dropped table [%s] (schema history not available)\n", change.Name))
		sql.WriteString(fmt.Sprintf("-- CREATE TABLE [%s] (...);\n\n", change.Name))
	}

	// 2. Rollback table alters (reverse the changes)
	for _, change := range diffResult.TablesToAlter {
		rollbackSQL := g.generateRollbackAlterTable(change, dbSchema)
		if rollbackSQL != "" {
			sql.WriteString(rollbackSQL)
			sql.WriteString("\n\n")
		}
	}

	// 3. Rollback table creates (drop created tables)
	for _, change := range diffResult.TablesToCreate {
		sql.WriteString(fmt.Sprintf("IF OBJECT_ID('[%s]', 'U') IS NOT NULL DROP TABLE [%s];\n\n", change.Name, change.Name))
	}

	return sql.String(), nil
}
