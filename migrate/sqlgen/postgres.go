// Package sqlgen generates migration SQL from schema changes.
package sqlgen

import (
	"fmt"
	"strings"

	"github.com/satishbabariya/prisma-go/migrate/diff"
	"github.com/satishbabariya/prisma-go/migrate/introspect"
)

// PostgresMigrationGenerator generates PostgreSQL migration SQL
type PostgresMigrationGenerator struct{}

// NewPostgresMigrationGenerator creates a new PostgreSQL migration generator
func NewPostgresMigrationGenerator() *PostgresMigrationGenerator {
	return &PostgresMigrationGenerator{}
}

// GenerateMigrationSQL generates SQL for a diff result
func (g *PostgresMigrationGenerator) GenerateMigrationSQL(diffResult *diff.DiffResult, dbSchema *introspect.DatabaseSchema) (string, error) {
	var sql strings.Builder
	
	sql.WriteString("-- Migration SQL generated by Prisma-Go\n")
	sql.WriteString("-- WARNING: Review this SQL before running it!\n\n")

	// Process changes in order: Create, Alter, Drop
	
	// 1. Create tables
	for _, change := range diffResult.TablesToCreate {
		createSQL, err := g.generateCreateTable(change.Name, dbSchema)
		if err != nil {
			return "", fmt.Errorf("failed to generate CREATE TABLE for %s: %w", change.Name, err)
		}
		sql.WriteString(createSQL)
		sql.WriteString("\n\n")
	}

	// 2. Alter tables
	for _, change := range diffResult.TablesToAlter {
		alterSQL := g.generateAlterTable(change)
		if alterSQL != "" {
			sql.WriteString(alterSQL)
			sql.WriteString("\n\n")
		}
	}

	// 3. Drop tables (with warnings)
	for _, change := range diffResult.TablesToDrop {
		sql.WriteString(fmt.Sprintf("-- WARNING: Dropping table '%s' will delete all data!\n", change.Name))
		sql.WriteString(fmt.Sprintf("DROP TABLE IF EXISTS \"%s\" CASCADE;\n\n", change.Name))
	}

	return sql.String(), nil
}

// generateCreateTable generates CREATE TABLE SQL
func (g *PostgresMigrationGenerator) generateCreateTable(tableName string, dbSchema *introspect.DatabaseSchema) (string, error) {
	// Find table in schema
	var table *introspect.Table
	for _, t := range dbSchema.Tables {
		if t.Name == tableName {
			table = &t
			break
		}
	}

	if table == nil {
		return "", fmt.Errorf("table %s not found in schema", tableName)
	}

	var sql strings.Builder
	sql.WriteString(fmt.Sprintf("CREATE TABLE \"%s\" (\n", tableName))

	// Columns
	columnDefs := []string{}
	for _, col := range table.Columns {
		colDef := g.generateColumnDefinition(col)
		columnDefs = append(columnDefs, "  "+colDef)
	}

	// Primary key
	if table.PrimaryKey != nil && len(table.PrimaryKey.Columns) > 0 {
		pkCols := make([]string, len(table.PrimaryKey.Columns))
		for i, col := range table.PrimaryKey.Columns {
			pkCols[i] = fmt.Sprintf("\"%s\"", col)
		}
		columnDefs = append(columnDefs, fmt.Sprintf("  PRIMARY KEY (%s)", strings.Join(pkCols, ", ")))
	}

	sql.WriteString(strings.Join(columnDefs, ",\n"))
	sql.WriteString("\n);")

	// Indexes
	for _, idx := range table.Indexes {
		sql.WriteString("\n")
		sql.WriteString(g.generateCreateIndex(tableName, idx))
	}

	// Foreign keys
	for _, fk := range table.ForeignKeys {
		sql.WriteString("\n")
		sql.WriteString(g.generateAddForeignKey(tableName, fk))
	}

	return sql.String(), nil
}

// generateColumnDefinition generates a column definition
func (g *PostgresMigrationGenerator) generateColumnDefinition(col introspect.Column) string {
	def := fmt.Sprintf("\"%s\" %s", col.Name, col.Type)

	if !col.Nullable {
		def += " NOT NULL"
	}

	if col.DefaultValue != nil && *col.DefaultValue != "" {
		def += fmt.Sprintf(" DEFAULT %s", *col.DefaultValue)
	}

	return def
}

// generateAlterTable generates ALTER TABLE SQL
func (g *PostgresMigrationGenerator) generateAlterTable(change diff.TableChange) string {
	if len(change.Changes) == 0 {
		return ""
	}

	var sql strings.Builder

	for _, ch := range change.Changes {
		switch ch.Type {
		case "AddColumn":
			sql.WriteString(fmt.Sprintf("-- Add column %s.%s\n", change.Name, ch.Column))
			sql.WriteString(fmt.Sprintf("ALTER TABLE \"%s\" ADD COLUMN \"%s\" %s;\n", 
				change.Name, ch.Column, "TEXT")) // Default type, should be improved

		case "DropColumn":
			sql.WriteString(fmt.Sprintf("-- WARNING: Dropping column %s.%s will delete all data!\n", change.Name, ch.Column))
			sql.WriteString(fmt.Sprintf("ALTER TABLE \"%s\" DROP COLUMN IF EXISTS \"%s\";\n", 
				change.Name, ch.Column))

		case "AlterColumn":
			sql.WriteString(fmt.Sprintf("-- Alter column %s.%s\n", change.Name, ch.Column))
			sql.WriteString(fmt.Sprintf("-- %s\n", ch.Description))
			// Note: Actual ALTER COLUMN syntax depends on the specific change

		case "CreateIndex":
			sql.WriteString(fmt.Sprintf("-- Create index %s\n", ch.Index))
			sql.WriteString(fmt.Sprintf("CREATE INDEX \"%s\" ON \"%s\" (\"%s\");\n", 
				ch.Index, change.Name, ch.Column))

		case "DropIndex":
			sql.WriteString(fmt.Sprintf("-- Drop index %s\n", ch.Index))
			sql.WriteString(fmt.Sprintf("DROP INDEX IF EXISTS \"%s\";\n", ch.Index))
		}
	}

	return sql.String()
}

// generateCreateIndex generates CREATE INDEX SQL
func (g *PostgresMigrationGenerator) generateCreateIndex(tableName string, idx introspect.Index) string {
	unique := ""
	if idx.IsUnique {
		unique = "UNIQUE "
	}

	cols := make([]string, len(idx.Columns))
	for i, col := range idx.Columns {
		cols[i] = fmt.Sprintf("\"%s\"", col)
	}

	return fmt.Sprintf("CREATE %sINDEX \"%s\" ON \"%s\" (%s);", 
		unique, idx.Name, tableName, strings.Join(cols, ", "))
}

// generateAddForeignKey generates ALTER TABLE ADD CONSTRAINT SQL for foreign keys
func (g *PostgresMigrationGenerator) generateAddForeignKey(tableName string, fk introspect.ForeignKey) string {
	cols := make([]string, len(fk.Columns))
	for i, col := range fk.Columns {
		cols[i] = fmt.Sprintf("\"%s\"", col)
	}

	refCols := make([]string, len(fk.ReferencedColumns))
	for i, col := range fk.ReferencedColumns {
		refCols[i] = fmt.Sprintf("\"%s\"", col)
	}

	sql := fmt.Sprintf("ALTER TABLE \"%s\" ADD CONSTRAINT \"%s\" FOREIGN KEY (%s) REFERENCES \"%s\" (%s)",
		tableName, fk.Name, strings.Join(cols, ", "), fk.ReferencedTable, strings.Join(refCols, ", "))

	if fk.OnUpdate != "" && fk.OnUpdate != "NO ACTION" {
		sql += fmt.Sprintf(" ON UPDATE %s", fk.OnUpdate)
	}

	if fk.OnDelete != "" && fk.OnDelete != "NO ACTION" {
		sql += fmt.Sprintf(" ON DELETE %s", fk.OnDelete)
	}

	sql += ";"

	return sql
}

