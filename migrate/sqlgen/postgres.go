// Package sqlgen generates migration SQL from schema changes.
package sqlgen

import (
	"fmt"
	"strings"

	"github.com/satishbabariya/prisma-go/migrate/diff"
	"github.com/satishbabariya/prisma-go/migrate/introspect"
)

// PostgresMigrationGenerator generates PostgreSQL migration SQL
type PostgresMigrationGenerator struct{}

// NewPostgresMigrationGenerator creates a new PostgreSQL migration generator
func NewPostgresMigrationGenerator() *PostgresMigrationGenerator {
	return &PostgresMigrationGenerator{}
}

// GenerateMigrationSQL generates SQL for a diff result
func (g *PostgresMigrationGenerator) GenerateMigrationSQL(diffResult *diff.DiffResult, dbSchema *introspect.DatabaseSchema) (string, error) {
	var sql strings.Builder

	sql.WriteString("-- Migration SQL generated by Prisma-Go\n")
	sql.WriteString("-- WARNING: Review this SQL before running it!\n\n")

	// Process changes in order: Create, Alter, Drop

	// 1. Create tables
	for _, change := range diffResult.TablesToCreate {
		// Find table in target schema (dbSchema is the target schema)
		var targetTable *introspect.Table
		for i := range dbSchema.Tables {
			if dbSchema.Tables[i].Name == change.Name {
				targetTable = &dbSchema.Tables[i]
				break
			}
		}
		if targetTable == nil {
			return "", fmt.Errorf("table %s not found in target schema", change.Name)
		}

		createSQL, err := g.generateCreateTableFromTable(targetTable)
		if err != nil {
			return "", fmt.Errorf("failed to generate CREATE TABLE for %s: %w", change.Name, err)
		}
		sql.WriteString(createSQL)
		sql.WriteString("\n\n")
	}

	// 2. Alter tables
	for _, change := range diffResult.TablesToAlter {
		alterSQL := g.generateAlterTable(change, dbSchema)
		if alterSQL != "" {
			sql.WriteString(alterSQL)
			sql.WriteString("\n\n")
		}
	}

	// 3. Drop tables (with warnings)
	for _, change := range diffResult.TablesToDrop {
		sql.WriteString(fmt.Sprintf("-- WARNING: Dropping table '%s' will delete all data!\n", change.Name))
		sql.WriteString(fmt.Sprintf("DROP TABLE IF EXISTS \"%s\" CASCADE;\n\n", change.Name))
	}

	// 4. Preserve check constraints, triggers, and stored procedures
	// These are preserved from the existing database schema
	if dbSchema != nil {
		// Preserve check constraints
		for _, constraint := range dbSchema.CheckConstraints {
			sql.WriteString(fmt.Sprintf("-- Preserving check constraint %s on table %s\n", constraint.Name, constraint.TableName))
			sql.WriteString(fmt.Sprintf("-- ALTER TABLE \"%s\" ADD CONSTRAINT \"%s\" CHECK (%s);\n\n", constraint.TableName, constraint.Name, constraint.Definition))
		}

		// Preserve triggers
		for _, trigger := range dbSchema.Triggers {
			sql.WriteString(fmt.Sprintf("-- Preserving trigger %s on table %s\n", trigger.Name, trigger.TableName))
			sql.WriteString(fmt.Sprintf("-- %s\n\n", trigger.Definition))
		}

		// Preserve stored procedures
		for _, proc := range dbSchema.StoredProcedures {
			sql.WriteString(fmt.Sprintf("-- Preserving stored procedure %s\n", proc.Name))
			sql.WriteString(fmt.Sprintf("-- %s\n\n", proc.Definition))
		}
	}

	return sql.String(), nil
}

// GenerateRollbackSQL generates rollback SQL for a diff result
func (g *PostgresMigrationGenerator) GenerateRollbackSQL(diffResult *diff.DiffResult, dbSchema *introspect.DatabaseSchema) (string, error) {
	return g.GenerateRollbackSQLWithPreviousSchema(diffResult, dbSchema, nil)
}

// GenerateRollbackSQLWithPreviousSchema generates rollback SQL using stored schema state
func (g *PostgresMigrationGenerator) GenerateRollbackSQLWithPreviousSchema(diffResult *diff.DiffResult, dbSchema *introspect.DatabaseSchema, previousSchema *introspect.DatabaseSchema) (string, error) {
	var sql strings.Builder

	sql.WriteString("-- Rollback SQL generated by Prisma-Go\n")
	sql.WriteString("-- WARNING: Review this SQL before running it!\n\n")

	// Rollback in reverse order: Drop, Alter, Create

	// 1. Rollback table drops (recreate dropped tables)
	for _, change := range diffResult.TablesToDrop {
		if previousSchema != nil {
			// Find table in previous schema
			var previousTable *introspect.Table
			for i := range previousSchema.Tables {
				if previousSchema.Tables[i].Name == change.Name {
					previousTable = &previousSchema.Tables[i]
					break
				}
			}
			if previousTable != nil {
				// Generate CREATE TABLE from stored schema
				createSQL, err := g.generateCreateTableFromTable(previousTable)
				if err != nil {
					return "", fmt.Errorf("failed to generate CREATE TABLE for %s: %w", change.Name, err)
				}
				sql.WriteString(createSQL)
				sql.WriteString("\n\n")
				continue
			}
		}
		// Fallback: generate placeholder if schema not available
		sql.WriteString(fmt.Sprintf("-- TODO: Recreate dropped table '%s' (schema history not available)\n", change.Name))
		sql.WriteString(fmt.Sprintf("-- CREATE TABLE \"%s\" (...);\n\n", change.Name))
	}

	// 2. Rollback table alters (reverse the changes)
	for _, change := range diffResult.TablesToAlter {
		rollbackSQL := g.generateRollbackAlterTable(change, dbSchema)
		if rollbackSQL != "" {
			sql.WriteString(rollbackSQL)
			sql.WriteString("\n\n")
		}
	}

	// 3. Rollback table creates (drop created tables)
	for _, change := range diffResult.TablesToCreate {
		sql.WriteString(fmt.Sprintf("DROP TABLE IF EXISTS \"%s\" CASCADE;\n\n", change.Name))
	}

	return sql.String(), nil
}

// generateRollbackAlterTable generates rollback SQL for ALTER TABLE changes
func (g *PostgresMigrationGenerator) generateRollbackAlterTable(change diff.TableChange, dbSchema *introspect.DatabaseSchema) string {
	if len(change.Changes) == 0 {
		return ""
	}

	var sql strings.Builder

	// Process changes in reverse order
	for i := len(change.Changes) - 1; i >= 0; i-- {
		ch := change.Changes[i]
		switch ch.Type {
		case "AddColumn":
			// Rollback: drop column
			sql.WriteString(fmt.Sprintf("ALTER TABLE \"%s\" DROP COLUMN IF EXISTS \"%s\";\n",
				change.Name, ch.Column))

		case "DropColumn":
			// Rollback: add column back (would need old column definition)
			// For now, generate a placeholder - full implementation requires schema history
			if ch.ColumnMetadata != nil {
				colDef := g.generateColumnDefinitionFromMetadata(ch.ColumnMetadata, ch.Column)
				sql.WriteString(fmt.Sprintf("ALTER TABLE \"%s\" ADD COLUMN \"%s\" %s;\n",
					change.Name, ch.Column, colDef))
			} else {
				sql.WriteString(fmt.Sprintf("-- TODO: Add back dropped column %s.%s (metadata missing)\n",
					change.Name, ch.Column))
			}

		case "AlterColumn":
			// Rollback: restore old column definition
			if ch.ColumnMetadata != nil && ch.ColumnMetadata.OldType != "" {
				// Restore old type
				sql.WriteString(fmt.Sprintf("ALTER TABLE \"%s\" ALTER COLUMN \"%s\" TYPE %s;\n",
					change.Name, ch.Column, ch.ColumnMetadata.OldType))
				// Restore old nullable state
				if ch.ColumnMetadata.OldNullable != nil {
					if *ch.ColumnMetadata.OldNullable {
						sql.WriteString(fmt.Sprintf("ALTER TABLE \"%s\" ALTER COLUMN \"%s\" DROP NOT NULL;\n",
							change.Name, ch.Column))
					} else {
						sql.WriteString(fmt.Sprintf("ALTER TABLE \"%s\" ALTER COLUMN \"%s\" SET NOT NULL;\n",
							change.Name, ch.Column))
					}
				}
			}

		case "CreateIndex":
			// Rollback: drop index
			sql.WriteString(fmt.Sprintf("DROP INDEX IF EXISTS \"%s\";\n", ch.Index))

		case "DropIndex":
			// Rollback: recreate index (would need old index definition)
			// For now, generate a placeholder - full implementation requires schema history
			sql.WriteString(fmt.Sprintf("-- TODO: Recreate dropped index %s (requires schema history)\n", ch.Index))
			sql.WriteString(fmt.Sprintf("-- CREATE INDEX \"%s\" ON \"%s\" (...);\n", ch.Index, change.Name))

		case "RenameIndex":
			// Rollback: rename back
			sql.WriteString(fmt.Sprintf("ALTER INDEX \"%s\" RENAME TO \"%s\";\n",
				ch.NewName, ch.OldName))

		case "CreateForeignKey":
			// Rollback: drop foreign key
			sql.WriteString(fmt.Sprintf("ALTER TABLE \"%s\" DROP CONSTRAINT IF EXISTS \"%s\";\n",
				change.Name, ch.Index))

		case "DropForeignKey":
			// Rollback: recreate foreign key (would need old FK definition)
			// For now, generate a placeholder - full implementation requires schema history
			sql.WriteString(fmt.Sprintf("-- TODO: Recreate dropped foreign key %s (requires schema history)\n", ch.Index))
			sql.WriteString(fmt.Sprintf("-- ALTER TABLE \"%s\" ADD CONSTRAINT \"%s\" FOREIGN KEY (...) REFERENCES ...;\n",
				change.Name, ch.Index))

		case "RenameForeignKey":
			// Rollback: rename back
			sql.WriteString(fmt.Sprintf("ALTER TABLE \"%s\" RENAME CONSTRAINT \"%s\" TO \"%s\";\n",
				change.Name, ch.NewName, ch.OldName))
		}
	}

	return sql.String()
}

// generateCreateTableFromTable generates CREATE TABLE SQL from a table definition
func (g *PostgresMigrationGenerator) generateCreateTableFromTable(table *introspect.Table) (string, error) {
	var sql strings.Builder
	sql.WriteString(fmt.Sprintf("CREATE TABLE \"%s\" (\n", table.Name))

	// Columns
	columnDefs := []string{}
	for _, col := range table.Columns {
		colDef := g.generateColumnDefinition(col)
		columnDefs = append(columnDefs, "  "+colDef)
	}

	// Primary key
	if table.PrimaryKey != nil && len(table.PrimaryKey.Columns) > 0 {
		pkCols := make([]string, len(table.PrimaryKey.Columns))
		for i, col := range table.PrimaryKey.Columns {
			pkCols[i] = fmt.Sprintf("\"%s\"", col)
		}
		columnDefs = append(columnDefs, fmt.Sprintf("  PRIMARY KEY (%s)", strings.Join(pkCols, ", ")))
	}

	sql.WriteString(strings.Join(columnDefs, ",\n"))
	sql.WriteString("\n);")

	// Indexes
	for _, idx := range table.Indexes {
		sql.WriteString("\n")
		sql.WriteString(g.generateCreateIndex(table.Name, idx))
	}

	// Foreign keys
	for _, fk := range table.ForeignKeys {
		sql.WriteString("\n")
		sql.WriteString(g.generateAddForeignKey(table.Name, fk))
	}

	return sql.String(), nil
}

// generateColumnDefinition generates a column definition
func (g *PostgresMigrationGenerator) generateColumnDefinition(col introspect.Column) string {
	def := fmt.Sprintf("\"%s\" %s", col.Name, col.Type)

	if !col.Nullable {
		def += " NOT NULL"
	}

	if col.DefaultValue != nil && *col.DefaultValue != "" {
		def += fmt.Sprintf(" DEFAULT %s", *col.DefaultValue)
	}

	return def
}

// generateAlterTable generates ALTER TABLE SQL
func (g *PostgresMigrationGenerator) generateAlterTable(change diff.TableChange, dbSchema *introspect.DatabaseSchema) string {
	if len(change.Changes) == 0 {
		return ""
	}

	var sql strings.Builder

	for _, ch := range change.Changes {
		switch ch.Type {
		case "AddColumn":
			sql.WriteString(fmt.Sprintf("-- Add column %s.%s\n", change.Name, ch.Column))
			if ch.ColumnMetadata != nil {
				colDef := g.generateColumnDefinitionFromMetadata(ch.ColumnMetadata, ch.Column)
				sql.WriteString(fmt.Sprintf("ALTER TABLE \"%s\" ADD COLUMN \"%s\" %s;\n",
					change.Name, ch.Column, colDef))
			} else {
				// Fallback to TEXT if metadata is missing
				sql.WriteString(fmt.Sprintf("ALTER TABLE \"%s\" ADD COLUMN \"%s\" TEXT;\n",
					change.Name, ch.Column))
			}

		case "DropColumn":
			sql.WriteString(fmt.Sprintf("-- WARNING: Dropping column %s.%s will delete all data!\n", change.Name, ch.Column))
			sql.WriteString(fmt.Sprintf("ALTER TABLE \"%s\" DROP COLUMN IF EXISTS \"%s\";\n",
				change.Name, ch.Column))

		case "AlterColumn":
			sql.WriteString(fmt.Sprintf("-- Alter column %s.%s\n", change.Name, ch.Column))
			sql.WriteString(fmt.Sprintf("-- %s\n", ch.Description))
			if ch.ColumnMetadata != nil {
				// PostgreSQL requires separate ALTER COLUMN statements for different changes
				// Type change
				if ch.ColumnMetadata.OldType != "" && ch.ColumnMetadata.OldType != ch.ColumnMetadata.Type {
					sql.WriteString(fmt.Sprintf("ALTER TABLE \"%s\" ALTER COLUMN \"%s\" TYPE %s;\n",
						change.Name, ch.Column, ch.ColumnMetadata.Type))
				}
				// Nullable change
				if ch.ColumnMetadata.OldNullable != nil && *ch.ColumnMetadata.OldNullable != ch.ColumnMetadata.Nullable {
					if ch.ColumnMetadata.Nullable {
						sql.WriteString(fmt.Sprintf("ALTER TABLE \"%s\" ALTER COLUMN \"%s\" DROP NOT NULL;\n",
							change.Name, ch.Column))
					} else {
						sql.WriteString(fmt.Sprintf("ALTER TABLE \"%s\" ALTER COLUMN \"%s\" SET NOT NULL;\n",
							change.Name, ch.Column))
					}
				}
				// Default change
				if ch.ColumnMetadata.DefaultValue != nil && *ch.ColumnMetadata.DefaultValue != "" {
					sql.WriteString(fmt.Sprintf("ALTER TABLE \"%s\" ALTER COLUMN \"%s\" SET DEFAULT %s;\n",
						change.Name, ch.Column, *ch.ColumnMetadata.DefaultValue))
				} else if ch.ColumnMetadata.OldNullable != nil {
					// Only remove default if we're sure it changed (heuristic: if old nullable is set, we're modifying)
					sql.WriteString(fmt.Sprintf("-- ALTER TABLE \"%s\" ALTER COLUMN \"%s\" DROP DEFAULT;\n",
						change.Name, ch.Column))
				}
			} else {
				// Fallback: try to infer from description or use safe defaults
				if ch.Description != "" {
					sql.WriteString(fmt.Sprintf("-- Column metadata missing, inferred from description: %s\n", ch.Description))
					sql.WriteString(fmt.Sprintf("-- ALTER TABLE \"%s\" ALTER COLUMN \"%s\" TYPE TEXT;\n",
						change.Name, ch.Column))
				} else {
					sql.WriteString(fmt.Sprintf("-- TODO: Column metadata missing, manual review required for %s.%s\n",
						change.Name, ch.Column))
				}
			}

		case "CreateIndex":
			sql.WriteString(fmt.Sprintf("-- Create index %s\n", ch.Index))
			sql.WriteString(fmt.Sprintf("CREATE INDEX \"%s\" ON \"%s\" (\"%s\");\n",
				ch.Index, change.Name, ch.Column))

		case "DropIndex":
			sql.WriteString(fmt.Sprintf("-- Drop index %s\n", ch.Index))
			sql.WriteString(fmt.Sprintf("DROP INDEX IF EXISTS \"%s\";\n", ch.Index))

		case "RenameIndex":
			sql.WriteString(fmt.Sprintf("-- Rename index %s to %s\n", ch.OldName, ch.NewName))
			sql.WriteString(fmt.Sprintf("ALTER INDEX \"%s\" RENAME TO \"%s\";\n",
				ch.OldName, ch.NewName))

		case "CreateForeignKey":
			sql.WriteString(fmt.Sprintf("-- Create foreign key %s\n", ch.Index))
			// Try to find foreign key in dbSchema
			if dbSchema != nil {
				for _, table := range dbSchema.Tables {
					if table.Name == change.Name {
						for _, fk := range table.ForeignKeys {
							if fk.Name == ch.Index {
								sql.WriteString(g.generateAddForeignKey(change.Name, fk))
								sql.WriteString("\n")
								break
							}
						}
					}
				}
			} else {
				// Fallback: generate placeholder SQL
				sql.WriteString(fmt.Sprintf("-- ALTER TABLE \"%s\" ADD CONSTRAINT \"%s\" FOREIGN KEY (...) REFERENCES ...;\n",
					change.Name, ch.Index))
			}

		case "DropForeignKey":
			sql.WriteString(fmt.Sprintf("-- Drop foreign key %s\n", ch.Index))
			sql.WriteString(fmt.Sprintf("ALTER TABLE \"%s\" DROP CONSTRAINT IF EXISTS \"%s\";\n",
				change.Name, ch.Index))

		case "RenameForeignKey":
			sql.WriteString(fmt.Sprintf("-- Rename foreign key %s to %s\n", ch.OldName, ch.NewName))
			sql.WriteString(fmt.Sprintf("ALTER TABLE \"%s\" RENAME CONSTRAINT \"%s\" TO \"%s\";\n",
				change.Name, ch.OldName, ch.NewName))
		}
	}

	return sql.String()
}

// generateCreateIndex generates CREATE INDEX SQL
func (g *PostgresMigrationGenerator) generateCreateIndex(tableName string, idx introspect.Index) string {
	unique := ""
	if idx.IsUnique {
		unique = "UNIQUE "
	}

	cols := make([]string, len(idx.Columns))
	for i, col := range idx.Columns {
		cols[i] = fmt.Sprintf("\"%s\"", col)
	}

	return fmt.Sprintf("CREATE %sINDEX \"%s\" ON \"%s\" (%s);",
		unique, idx.Name, tableName, strings.Join(cols, ", "))
}

// generateAddForeignKey generates ALTER TABLE ADD CONSTRAINT SQL for foreign keys
func (g *PostgresMigrationGenerator) generateAddForeignKey(tableName string, fk introspect.ForeignKey) string {
	cols := make([]string, len(fk.Columns))
	for i, col := range fk.Columns {
		cols[i] = fmt.Sprintf("\"%s\"", col)
	}

	refCols := make([]string, len(fk.ReferencedColumns))
	for i, col := range fk.ReferencedColumns {
		refCols[i] = fmt.Sprintf("\"%s\"", col)
	}

	sql := fmt.Sprintf("ALTER TABLE \"%s\" ADD CONSTRAINT \"%s\" FOREIGN KEY (%s) REFERENCES \"%s\" (%s)",
		tableName, fk.Name, strings.Join(cols, ", "), fk.ReferencedTable, strings.Join(refCols, ", "))

	if fk.OnUpdate != "" && fk.OnUpdate != "NO ACTION" {
		sql += fmt.Sprintf(" ON UPDATE %s", fk.OnUpdate)
	}

	if fk.OnDelete != "" && fk.OnDelete != "NO ACTION" {
		sql += fmt.Sprintf(" ON DELETE %s", fk.OnDelete)
	}

	sql += ";"

	return sql
}

// generateColumnDefinitionFromMetadata generates a column definition from ColumnMetadata
func (g *PostgresMigrationGenerator) generateColumnDefinitionFromMetadata(meta *diff.ColumnMetadata, columnName string) string {
	def := meta.Type

	if !meta.Nullable {
		def += " NOT NULL"
	}

	if meta.DefaultValue != nil && *meta.DefaultValue != "" {
		def += fmt.Sprintf(" DEFAULT %s", *meta.DefaultValue)
	}

	return def
}
