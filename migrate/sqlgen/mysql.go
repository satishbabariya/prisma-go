// Package sqlgen generates migration SQL for MySQL.
package sqlgen

import (
	"fmt"
	"strings"

	"github.com/satishbabariya/prisma-go/migrate/diff"
	"github.com/satishbabariya/prisma-go/migrate/introspect"
)

// MySQLMigrationGenerator generates MySQL migration SQL
type MySQLMigrationGenerator struct{}

// NewMySQLMigrationGenerator creates a new MySQL migration generator
func NewMySQLMigrationGenerator() *MySQLMigrationGenerator {
	return &MySQLMigrationGenerator{}
}

// GenerateMigrationSQL generates SQL for a diff result
func (g *MySQLMigrationGenerator) GenerateMigrationSQL(diffResult *diff.DiffResult, dbSchema *introspect.DatabaseSchema) (string, error) {
	var sql strings.Builder
	
	sql.WriteString("-- Migration SQL generated by Prisma-Go for MySQL\n")
	sql.WriteString("-- WARNING: Review this SQL before running it!\n\n")

	// 1. Create tables
	for _, change := range diffResult.TablesToCreate {
		createSQL, err := g.generateCreateTable(change.Name, dbSchema)
		if err != nil {
			return "", fmt.Errorf("failed to generate CREATE TABLE for %s: %w", change.Name, err)
		}
		sql.WriteString(createSQL)
		sql.WriteString("\n\n")
	}

	// 2. Alter tables
	for _, change := range diffResult.TablesToAlter {
		alterSQL := g.generateAlterTable(change)
		if alterSQL != "" {
			sql.WriteString(alterSQL)
			sql.WriteString("\n\n")
		}
	}

	// 3. Drop tables
	for _, change := range diffResult.TablesToDrop {
		sql.WriteString(fmt.Sprintf("-- WARNING: Dropping table `%s` will delete all data!\n", change.Name))
		sql.WriteString(fmt.Sprintf("DROP TABLE IF EXISTS `%s`;\n\n", change.Name))
	}

	return sql.String(), nil
}

// generateCreateTable generates CREATE TABLE SQL for MySQL
func (g *MySQLMigrationGenerator) generateCreateTable(tableName string, dbSchema *introspect.DatabaseSchema) (string, error) {
	var table *introspect.Table
	for _, t := range dbSchema.Tables {
		if t.Name == tableName {
			table = &t
			break
		}
	}

	if table == nil {
		return "", fmt.Errorf("table %s not found in schema", tableName)
	}

	var sql strings.Builder
	sql.WriteString(fmt.Sprintf("CREATE TABLE `%s` (\n", tableName))

	// Columns
	columnDefs := []string{}
	for _, col := range table.Columns {
		colDef := g.generateColumnDefinition(col)
		columnDefs = append(columnDefs, "  "+colDef)
	}

	// Primary key
	if table.PrimaryKey != nil && len(table.PrimaryKey.Columns) > 0 {
		pkCols := make([]string, len(table.PrimaryKey.Columns))
		for i, col := range table.PrimaryKey.Columns {
			pkCols[i] = fmt.Sprintf("`%s`", col)
		}
		columnDefs = append(columnDefs, fmt.Sprintf("  PRIMARY KEY (%s)", strings.Join(pkCols, ", ")))
	}

	sql.WriteString(strings.Join(columnDefs, ",\n"))
	sql.WriteString("\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;")

	// Indexes
	for _, idx := range table.Indexes {
		sql.WriteString("\n")
		sql.WriteString(g.generateCreateIndex(tableName, idx))
	}

	// Foreign keys
	for _, fk := range table.ForeignKeys {
		sql.WriteString("\n")
		sql.WriteString(g.generateAddForeignKey(tableName, fk))
	}

	return sql.String(), nil
}

// generateColumnDefinition generates a column definition for MySQL
func (g *MySQLMigrationGenerator) generateColumnDefinition(col introspect.Column) string {
	// Map generic types to MySQL types
	mysqlType := g.mapToMySQLType(col.Type)
	def := fmt.Sprintf("`%s` %s", col.Name, mysqlType)

	if !col.Nullable {
		def += " NOT NULL"
	}

	if col.AutoIncrement {
		def += " AUTO_INCREMENT"
	} else if col.DefaultValue != nil && *col.DefaultValue != "" {
		def += fmt.Sprintf(" DEFAULT %s", *col.DefaultValue)
	}

	return def
}

// mapToMySQLType maps generic types to MySQL types
func (g *MySQLMigrationGenerator) mapToMySQLType(genericType string) string {
	upperType := strings.ToUpper(genericType)
	
	switch {
	case strings.HasPrefix(upperType, "SERIAL"):
		return "INT"
	case strings.HasPrefix(upperType, "BIGSERIAL"):
		return "BIGINT"
	case upperType == "INTEGER" || upperType == "INT4":
		return "INT"
	case upperType == "BIGINT" || upperType == "INT8":
		return "BIGINT"
	case upperType == "SMALLINT" || upperType == "INT2":
		return "SMALLINT"
	case upperType == "BOOLEAN" || upperType == "BOOL":
		return "TINYINT(1)"
	case strings.HasPrefix(upperType, "VARCHAR"):
		return genericType
	case upperType == "TEXT":
		return "TEXT"
	case strings.HasPrefix(upperType, "DECIMAL"):
		return genericType
	case strings.HasPrefix(upperType, "NUMERIC"):
		// Convert NUMERIC to DECIMAL for MySQL
		return strings.Replace(genericType, "NUMERIC", "DECIMAL", 1)
	case upperType == "REAL" || upperType == "FLOAT4":
		return "FLOAT"
	case upperType == "DOUBLE PRECISION" || upperType == "FLOAT8":
		return "DOUBLE"
	case upperType == "TIMESTAMP" || strings.Contains(upperType, "TIMESTAMP"):
		return "TIMESTAMP"
	case upperType == "TIMESTAMPTZ":
		return "TIMESTAMP" // MySQL doesn't have timezone support
	case upperType == "DATE":
		return "DATE"
	case upperType == "TIME":
		return "TIME"
	case upperType == "JSON" || upperType == "JSONB":
		return "JSON"
	case upperType == "UUID":
		return "CHAR(36)"
	case upperType == "BYTEA":
		return "BLOB"
	default:
		return genericType
	}
}

// generateAlterTable generates ALTER TABLE SQL for MySQL
func (g *MySQLMigrationGenerator) generateAlterTable(change diff.TableChange) string {
	if len(change.Changes) == 0 {
		return ""
	}

	var sql strings.Builder

	for _, ch := range change.Changes {
		switch ch.Type {
		case "AddColumn":
			sql.WriteString(fmt.Sprintf("-- Add column %s.%s\n", change.Name, ch.Column))
			sql.WriteString(fmt.Sprintf("ALTER TABLE `%s` ADD COLUMN `%s` TEXT;\n", 
				change.Name, ch.Column))

		case "DropColumn":
			sql.WriteString(fmt.Sprintf("-- WARNING: Dropping column %s.%s will delete all data!\n", change.Name, ch.Column))
			sql.WriteString(fmt.Sprintf("ALTER TABLE `%s` DROP COLUMN `%s`;\n", 
				change.Name, ch.Column))

		case "AlterColumn":
			sql.WriteString(fmt.Sprintf("-- Alter column %s.%s\n", change.Name, ch.Column))
			sql.WriteString(fmt.Sprintf("-- %s\n", ch.Description))
			// Note: MySQL uses MODIFY COLUMN for alterations

		case "CreateIndex":
			sql.WriteString(fmt.Sprintf("-- Create index %s\n", ch.Index))
			sql.WriteString(fmt.Sprintf("CREATE INDEX `%s` ON `%s` (`%s`);\n", 
				ch.Index, change.Name, ch.Column))

		case "DropIndex":
			sql.WriteString(fmt.Sprintf("-- Drop index %s\n", ch.Index))
			sql.WriteString(fmt.Sprintf("DROP INDEX `%s` ON `%s`;\n", ch.Index, change.Name))
		}
	}

	return sql.String()
}

// generateCreateIndex generates CREATE INDEX SQL for MySQL
func (g *MySQLMigrationGenerator) generateCreateIndex(tableName string, idx introspect.Index) string {
	unique := ""
	if idx.IsUnique {
		unique = "UNIQUE "
	}

	cols := make([]string, len(idx.Columns))
	for i, col := range idx.Columns {
		cols[i] = fmt.Sprintf("`%s`", col)
	}

	return fmt.Sprintf("CREATE %sINDEX `%s` ON `%s` (%s);", 
		unique, idx.Name, tableName, strings.Join(cols, ", "))
}

// generateAddForeignKey generates ALTER TABLE ADD CONSTRAINT SQL for MySQL
func (g *MySQLMigrationGenerator) generateAddForeignKey(tableName string, fk introspect.ForeignKey) string {
	cols := make([]string, len(fk.Columns))
	for i, col := range fk.Columns {
		cols[i] = fmt.Sprintf("`%s`", col)
	}

	refCols := make([]string, len(fk.ReferencedColumns))
	for i, col := range fk.ReferencedColumns {
		refCols[i] = fmt.Sprintf("`%s`", col)
	}

	sql := fmt.Sprintf("ALTER TABLE `%s` ADD CONSTRAINT `%s` FOREIGN KEY (%s) REFERENCES `%s` (%s)",
		tableName, fk.Name, strings.Join(cols, ", "), fk.ReferencedTable, strings.Join(refCols, ", "))

	if fk.OnUpdate != "" && fk.OnUpdate != "NO ACTION" {
		sql += fmt.Sprintf(" ON UPDATE %s", fk.OnUpdate)
	}

	if fk.OnDelete != "" && fk.OnDelete != "NO ACTION" {
		sql += fmt.Sprintf(" ON DELETE %s", fk.OnDelete)
	}

	sql += ";"

	return sql
}

