// Package sqlgen generates migration SQL for MySQL.
package sqlgen

import (
	"fmt"
	"strings"

	"github.com/satishbabariya/prisma-go/migrate/diff"
	"github.com/satishbabariya/prisma-go/migrate/introspect"
)

// MySQLMigrationGenerator generates MySQL migration SQL
type MySQLMigrationGenerator struct{}

// NewMySQLMigrationGenerator creates a new MySQL migration generator
func NewMySQLMigrationGenerator() *MySQLMigrationGenerator {
	return &MySQLMigrationGenerator{}
}

// GenerateMigrationSQL generates SQL for a diff result
func (g *MySQLMigrationGenerator) GenerateMigrationSQL(diffResult *diff.DiffResult, dbSchema *introspect.DatabaseSchema) (string, error) {
	var sql strings.Builder

	sql.WriteString("-- Migration SQL generated by Prisma-Go for MySQL\n")
	sql.WriteString("-- WARNING: Review this SQL before running it!\n\n")

	// 1. Create tables
	for _, change := range diffResult.TablesToCreate {
		// Find table in target schema (dbSchema is the target schema)
		var targetTable *introspect.Table
		for i := range dbSchema.Tables {
			if dbSchema.Tables[i].Name == change.Name {
				targetTable = &dbSchema.Tables[i]
				break
			}
		}
		if targetTable == nil {
			return "", fmt.Errorf("table %s not found in target schema", change.Name)
		}

		createSQL, err := g.generateCreateTableFromTable(targetTable)
		if err != nil {
			return "", fmt.Errorf("failed to generate CREATE TABLE for %s: %w", change.Name, err)
		}
		sql.WriteString(createSQL)
		sql.WriteString("\n\n")
	}

	// 2. Alter tables
	for _, change := range diffResult.TablesToAlter {
		alterSQL := g.generateAlterTable(change)
		if alterSQL != "" {
			sql.WriteString(alterSQL)
			sql.WriteString("\n\n")
		}
	}

	// 3. Drop tables
	for _, change := range diffResult.TablesToDrop {
		sql.WriteString(fmt.Sprintf("-- WARNING: Dropping table `%s` will delete all data!\n", change.Name))
		sql.WriteString(fmt.Sprintf("DROP TABLE IF EXISTS `%s`;\n\n", change.Name))
	}

	return sql.String(), nil
}

// GenerateRollbackSQL generates rollback SQL for a diff result
func (g *MySQLMigrationGenerator) GenerateRollbackSQL(diffResult *diff.DiffResult, dbSchema *introspect.DatabaseSchema) (string, error) {
	var sql strings.Builder

	sql.WriteString("-- Rollback SQL generated by Prisma-Go for MySQL\n")
	sql.WriteString("-- WARNING: Review this SQL before running it!\n\n")

	// Rollback in reverse order: Drop, Alter, Create

	// 1. Rollback table drops (recreate dropped tables)
	for _, change := range diffResult.TablesToDrop {
		sql.WriteString(fmt.Sprintf("-- TODO: Recreate dropped table `%s`\n", change.Name))
		sql.WriteString(fmt.Sprintf("-- CREATE TABLE `%s` (...);\n\n", change.Name))
	}

	// 2. Rollback table alters
	for _, change := range diffResult.TablesToAlter {
		rollbackSQL := g.generateRollbackAlterTable(change)
		if rollbackSQL != "" {
			sql.WriteString(rollbackSQL)
			sql.WriteString("\n\n")
		}
	}

	// 3. Rollback table creates (drop created tables)
	for _, change := range diffResult.TablesToCreate {
		sql.WriteString(fmt.Sprintf("DROP TABLE IF EXISTS `%s`;\n\n", change.Name))
	}

	return sql.String(), nil
}

// generateRollbackAlterTable generates rollback SQL for ALTER TABLE changes
func (g *MySQLMigrationGenerator) generateRollbackAlterTable(change diff.TableChange) string {
	if len(change.Changes) == 0 {
		return ""
	}

	var sql strings.Builder

	// Process changes in reverse order
	for i := len(change.Changes) - 1; i >= 0; i-- {
		ch := change.Changes[i]
		switch ch.Type {
		case "AddColumn":
			sql.WriteString(fmt.Sprintf("ALTER TABLE `%s` DROP COLUMN `%s`;\n",
				change.Name, ch.Column))

		case "DropColumn":
			sql.WriteString(fmt.Sprintf("-- TODO: Add back dropped column %s.%s\n",
				change.Name, ch.Column))

		case "AlterColumn":
			if ch.ColumnMetadata != nil && ch.ColumnMetadata.OldType != "" {
				oldType := g.mapToMySQLType(ch.ColumnMetadata.OldType)
				colDef := oldType
				if ch.ColumnMetadata.OldNullable != nil && !*ch.ColumnMetadata.OldNullable {
					colDef += " NOT NULL"
				}
				sql.WriteString(fmt.Sprintf("ALTER TABLE `%s` MODIFY COLUMN `%s` %s;\n",
					change.Name, ch.Column, colDef))
			}

		case "CreateIndex":
			sql.WriteString(fmt.Sprintf("DROP INDEX `%s` ON `%s`;\n", ch.Index, change.Name))

		case "DropIndex":
			sql.WriteString(fmt.Sprintf("-- TODO: Recreate dropped index %s\n", ch.Index))

		case "RenameIndex":
			sql.WriteString(fmt.Sprintf("ALTER TABLE `%s` RENAME INDEX `%s` TO `%s`;\n",
				change.Name, ch.NewName, ch.OldName))

		case "CreateForeignKey":
			sql.WriteString(fmt.Sprintf("-- TODO: Drop foreign key %s\n", ch.Index))

		case "DropForeignKey":
			sql.WriteString(fmt.Sprintf("-- TODO: Recreate dropped foreign key %s\n", ch.Index))

		case "RenameForeignKey":
			sql.WriteString(fmt.Sprintf("ALTER TABLE `%s` RENAME CONSTRAINT `%s` TO `%s`;\n",
				change.Name, ch.NewName, ch.OldName))
		}
	}

	return sql.String()
}

// generateCreateTableFromTable generates CREATE TABLE SQL for MySQL from a table definition
func (g *MySQLMigrationGenerator) generateCreateTableFromTable(table *introspect.Table) (string, error) {
	var sql strings.Builder
	sql.WriteString(fmt.Sprintf("CREATE TABLE `%s` (\n", table.Name))

	// Columns
	columnDefs := []string{}
	for _, col := range table.Columns {
		colDef := g.generateColumnDefinition(col)
		columnDefs = append(columnDefs, "  "+colDef)
	}

	// Primary key
	if table.PrimaryKey != nil && len(table.PrimaryKey.Columns) > 0 {
		pkCols := make([]string, len(table.PrimaryKey.Columns))
		for i, col := range table.PrimaryKey.Columns {
			pkCols[i] = fmt.Sprintf("`%s`", col)
		}
		columnDefs = append(columnDefs, fmt.Sprintf("  PRIMARY KEY (%s)", strings.Join(pkCols, ", ")))
	}

	sql.WriteString(strings.Join(columnDefs, ",\n"))
	sql.WriteString("\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;")

	// Indexes
	for _, idx := range table.Indexes {
		sql.WriteString("\n")
		sql.WriteString(g.generateCreateIndex(table.Name, idx))
	}

	// Foreign keys
	for _, fk := range table.ForeignKeys {
		sql.WriteString("\n")
		sql.WriteString(g.generateAddForeignKey(table.Name, fk))
	}

	return sql.String(), nil
}

// generateColumnDefinition generates a column definition for MySQL
func (g *MySQLMigrationGenerator) generateColumnDefinition(col introspect.Column) string {
	// Map generic types to MySQL types
	mysqlType := g.mapToMySQLType(col.Type)
	def := fmt.Sprintf("`%s` %s", col.Name, mysqlType)

	if !col.Nullable {
		def += " NOT NULL"
	}

	if col.AutoIncrement {
		def += " AUTO_INCREMENT"
	} else if col.DefaultValue != nil && *col.DefaultValue != "" {
		def += fmt.Sprintf(" DEFAULT %s", *col.DefaultValue)
	}

	return def
}

// mapToMySQLType maps generic types to MySQL types
func (g *MySQLMigrationGenerator) mapToMySQLType(genericType string) string {
	upperType := strings.ToUpper(genericType)

	switch {
	case strings.HasPrefix(upperType, "SERIAL"):
		return "INT"
	case strings.HasPrefix(upperType, "BIGSERIAL"):
		return "BIGINT"
	case upperType == "INTEGER" || upperType == "INT4":
		return "INT"
	case upperType == "BIGINT" || upperType == "INT8":
		return "BIGINT"
	case upperType == "SMALLINT" || upperType == "INT2":
		return "SMALLINT"
	case upperType == "BOOLEAN" || upperType == "BOOL":
		return "TINYINT(1)"
	case strings.HasPrefix(upperType, "VARCHAR"):
		return genericType
	case upperType == "TEXT":
		return "TEXT"
	case strings.HasPrefix(upperType, "DECIMAL"):
		return genericType
	case strings.HasPrefix(upperType, "NUMERIC"):
		// Convert NUMERIC to DECIMAL for MySQL
		return strings.Replace(genericType, "NUMERIC", "DECIMAL", 1)
	case upperType == "REAL" || upperType == "FLOAT4":
		return "FLOAT"
	case upperType == "DOUBLE PRECISION" || upperType == "FLOAT8":
		return "DOUBLE"
	case upperType == "TIMESTAMP" || strings.Contains(upperType, "TIMESTAMP"):
		return "TIMESTAMP"
	case upperType == "TIMESTAMPTZ":
		return "TIMESTAMP" // MySQL doesn't have timezone support
	case upperType == "DATE":
		return "DATE"
	case upperType == "TIME":
		return "TIME"
	case upperType == "JSON" || upperType == "JSONB":
		return "JSON"
	case upperType == "UUID":
		return "CHAR(36)"
	case upperType == "BYTEA":
		return "BLOB"
	default:
		return genericType
	}
}

// generateAlterTable generates ALTER TABLE SQL for MySQL
func (g *MySQLMigrationGenerator) generateAlterTable(change diff.TableChange) string {
	if len(change.Changes) == 0 {
		return ""
	}

	var sql strings.Builder

	for _, ch := range change.Changes {
		switch ch.Type {
		case "AddColumn":
			sql.WriteString(fmt.Sprintf("-- Add column %s.%s\n", change.Name, ch.Column))
			if ch.ColumnMetadata != nil {
				colDef := g.generateColumnDefinitionFromMetadata(ch.ColumnMetadata, ch.Column)
				sql.WriteString(fmt.Sprintf("ALTER TABLE `%s` ADD COLUMN `%s` %s;\n",
					change.Name, ch.Column, colDef))
			} else {
				// Fallback to TEXT if metadata is missing
				sql.WriteString(fmt.Sprintf("ALTER TABLE `%s` ADD COLUMN `%s` TEXT;\n",
					change.Name, ch.Column))
			}

		case "DropColumn":
			sql.WriteString(fmt.Sprintf("-- WARNING: Dropping column %s.%s will delete all data!\n", change.Name, ch.Column))
			sql.WriteString(fmt.Sprintf("ALTER TABLE `%s` DROP COLUMN `%s`;\n",
				change.Name, ch.Column))

		case "AlterColumn":
			sql.WriteString(fmt.Sprintf("-- Alter column %s.%s\n", change.Name, ch.Column))
			sql.WriteString(fmt.Sprintf("-- %s\n", ch.Description))
			if ch.ColumnMetadata != nil {
				colDef := g.generateColumnDefinitionFromMetadata(ch.ColumnMetadata, ch.Column)
				sql.WriteString(fmt.Sprintf("ALTER TABLE `%s` MODIFY COLUMN `%s` %s;\n",
					change.Name, ch.Column, colDef))
			} else {
				// Fallback: just a comment if metadata is missing
				sql.WriteString(fmt.Sprintf("-- TODO: Column metadata missing, manual review required\n"))
			}

		case "CreateIndex":
			sql.WriteString(fmt.Sprintf("-- Create index %s\n", ch.Index))
			sql.WriteString(fmt.Sprintf("CREATE INDEX `%s` ON `%s` (`%s`);\n",
				ch.Index, change.Name, ch.Column))

		case "DropIndex":
			sql.WriteString(fmt.Sprintf("-- Drop index %s\n", ch.Index))
			sql.WriteString(fmt.Sprintf("DROP INDEX `%s` ON `%s`;\n", ch.Index, change.Name))

		case "RenameIndex":
			sql.WriteString(fmt.Sprintf("-- Rename index %s to %s\n", ch.OldName, ch.NewName))
			sql.WriteString(fmt.Sprintf("ALTER TABLE `%s` RENAME INDEX `%s` TO `%s`;\n",
				change.Name, ch.OldName, ch.NewName))

		case "CreateForeignKey":
			sql.WriteString(fmt.Sprintf("-- Create foreign key %s\n", ch.Index))
			// Note: Foreign key creation SQL would need FK metadata
			sql.WriteString(fmt.Sprintf("-- TODO: Generate ALTER TABLE ADD FOREIGN KEY SQL\n"))

		case "DropForeignKey":
			sql.WriteString(fmt.Sprintf("-- Drop foreign key %s\n", ch.Index))
			sql.WriteString(fmt.Sprintf("-- TODO: Generate ALTER TABLE DROP FOREIGN KEY SQL\n"))

		case "RenameForeignKey":
			sql.WriteString(fmt.Sprintf("-- Rename foreign key %s to %s\n", ch.OldName, ch.NewName))
			sql.WriteString(fmt.Sprintf("ALTER TABLE `%s` RENAME CONSTRAINT `%s` TO `%s`;\n",
				change.Name, ch.OldName, ch.NewName))
		}
	}

	return sql.String()
}

// generateCreateIndex generates CREATE INDEX SQL for MySQL
func (g *MySQLMigrationGenerator) generateCreateIndex(tableName string, idx introspect.Index) string {
	unique := ""
	if idx.IsUnique {
		unique = "UNIQUE "
	}

	cols := make([]string, len(idx.Columns))
	for i, col := range idx.Columns {
		cols[i] = fmt.Sprintf("`%s`", col)
	}

	return fmt.Sprintf("CREATE %sINDEX `%s` ON `%s` (%s);",
		unique, idx.Name, tableName, strings.Join(cols, ", "))
}

// generateAddForeignKey generates ALTER TABLE ADD CONSTRAINT SQL for MySQL
func (g *MySQLMigrationGenerator) generateAddForeignKey(tableName string, fk introspect.ForeignKey) string {
	cols := make([]string, len(fk.Columns))
	for i, col := range fk.Columns {
		cols[i] = fmt.Sprintf("`%s`", col)
	}

	refCols := make([]string, len(fk.ReferencedColumns))
	for i, col := range fk.ReferencedColumns {
		refCols[i] = fmt.Sprintf("`%s`", col)
	}

	sql := fmt.Sprintf("ALTER TABLE `%s` ADD CONSTRAINT `%s` FOREIGN KEY (%s) REFERENCES `%s` (%s)",
		tableName, fk.Name, strings.Join(cols, ", "), fk.ReferencedTable, strings.Join(refCols, ", "))

	if fk.OnUpdate != "" && fk.OnUpdate != "NO ACTION" {
		sql += fmt.Sprintf(" ON UPDATE %s", fk.OnUpdate)
	}

	if fk.OnDelete != "" && fk.OnDelete != "NO ACTION" {
		sql += fmt.Sprintf(" ON DELETE %s", fk.OnDelete)
	}

	sql += ";"

	return sql
}

// generateColumnDefinitionFromMetadata generates a column definition from ColumnMetadata
func (g *MySQLMigrationGenerator) generateColumnDefinitionFromMetadata(meta *diff.ColumnMetadata, columnName string) string {
	// Map generic types to MySQL types
	mysqlType := g.mapToMySQLType(meta.Type)
	def := mysqlType

	if !meta.Nullable {
		def += " NOT NULL"
	}

	if meta.AutoIncrement {
		def += " AUTO_INCREMENT"
	} else if meta.DefaultValue != nil && *meta.DefaultValue != "" {
		def += fmt.Sprintf(" DEFAULT %s", *meta.DefaultValue)
	}

	return def
}
